{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"REST-API Documentaci\u00f3n acerca de la creaci\u00f3n e implementaci\u00f3n paso a paso de un REST API, utilizando las tecnolog\u00edas de Swagger, Node.js, express, SQL y Azure. A continuaci\u00f3n, daremos una peque\u00f1a introducci\u00f3n acerca de qu\u00e9 es un REST-API, as\u00ed como tambi\u00e9n describiremos todos las tecnolog\u00edas que vamos a estar utilizando a lo largo del tutorial","title":"Inicio"},{"location":"#rest-api","text":"Documentaci\u00f3n acerca de la creaci\u00f3n e implementaci\u00f3n paso a paso de un REST API, utilizando las tecnolog\u00edas de Swagger, Node.js, express, SQL y Azure. A continuaci\u00f3n, daremos una peque\u00f1a introducci\u00f3n acerca de qu\u00e9 es un REST-API, as\u00ed como tambi\u00e9n describiremos todos las tecnolog\u00edas que vamos a estar utilizando a lo largo del tutorial","title":"REST-API"},{"location":"apiKey/","text":"Asignaci\u00f3n de API-KEY a nuestro REST-API Todas las API deben protegerse mediante una autenticaci\u00f3n y una supervisi\u00f3n adecuadas. Las dos maneras principales de proteger las API de REST son las siguientes: Tokens de autenticaci\u00f3n Se utilizan para autorizar a los usuarios a hacer la llamada a la API. Los tokens de autenticaci\u00f3n comprueban que los usuarios son quienes dicen ser y que tienen los derechos de acceso para esa llamada concreta a la API. Por ejemplo, cuando inicia sesi\u00f3n en el servidor de correo electr\u00f3nico, el cliente de correo electr\u00f3nico utiliza tokens de autenticaci\u00f3n para un acceso seguro. Claves de API Las claves de API verifican el programa o la aplicaci\u00f3n que hace la llamada a la API. Identifican la aplicaci\u00f3n y se aseguran de que tiene los derechos de acceso necesarios para hacer la llamada a la API en cuesti\u00f3n. Las claves de API no son tan seguras como los tokens, pero permiten supervisar la API para recopilar datos sobre su uso. Es posible que haya notado una larga cadena de caracteres y n\u00fameros en la URL de su navegador cuando visita diferentes sitios web. Esta cadena es una clave de la API que el sitio web utiliza para hacer llamadas internas a la API. Lleg\u00f3 el momento de darle, un poco m\u00e1s de seguridad a nuestro API, es decir, de darle acceso solo a aquellas clientes que nosotros queramos. Para esto, podr\u00edamos configurar los CORS de nuestro REST-API y limitarlo solo al 'origen' que nosotros deseemos. Pero hay casos en el que debemos habilitar los CORS para que cualquier origen pueda acceder. \u00bfEntonces que podemos hacer? Una de las soluciones es solicitar un API-KEY que venga en los headers de la solicitud. Validamos que sea correcto, y si es correcto podemos continuar con nuestra petici\u00f3n. \u00bfTe imaginas c\u00f3mo? Reto Este es el reto de nuestro proyecto. Ya te di todas las bases acerca de c\u00f3mo crear el API-REST y de c\u00f3mo funciona todo nuestro c\u00f3digo, es tu turno de poner en pr\u00e1ctica lo visto anteriormente para que le asignes la validaci\u00f3n por API-KEY a nuestro proyecto PISTA: \u00a1\u00a1\u00a1\u00a1USA LOS MIDDLEWARE!!!! \u00a1\u00a1Cuando tengas todo listo, utiliza POSTMAN para realizar las pruebas!! \u00a1No olvides poner en los headers el api-key que configuraste! \u00a1\u00a1Cualquier problema que se te presente, no dudes en escribirme!!","title":"6. Asignaci\u00f3n API-KEY"},{"location":"apiKey/#asignacion-de-api-key-a-nuestro-rest-api","text":"Todas las API deben protegerse mediante una autenticaci\u00f3n y una supervisi\u00f3n adecuadas. Las dos maneras principales de proteger las API de REST son las siguientes: Tokens de autenticaci\u00f3n Se utilizan para autorizar a los usuarios a hacer la llamada a la API. Los tokens de autenticaci\u00f3n comprueban que los usuarios son quienes dicen ser y que tienen los derechos de acceso para esa llamada concreta a la API. Por ejemplo, cuando inicia sesi\u00f3n en el servidor de correo electr\u00f3nico, el cliente de correo electr\u00f3nico utiliza tokens de autenticaci\u00f3n para un acceso seguro. Claves de API Las claves de API verifican el programa o la aplicaci\u00f3n que hace la llamada a la API. Identifican la aplicaci\u00f3n y se aseguran de que tiene los derechos de acceso necesarios para hacer la llamada a la API en cuesti\u00f3n. Las claves de API no son tan seguras como los tokens, pero permiten supervisar la API para recopilar datos sobre su uso. Es posible que haya notado una larga cadena de caracteres y n\u00fameros en la URL de su navegador cuando visita diferentes sitios web. Esta cadena es una clave de la API que el sitio web utiliza para hacer llamadas internas a la API. Lleg\u00f3 el momento de darle, un poco m\u00e1s de seguridad a nuestro API, es decir, de darle acceso solo a aquellas clientes que nosotros queramos. Para esto, podr\u00edamos configurar los CORS de nuestro REST-API y limitarlo solo al 'origen' que nosotros deseemos. Pero hay casos en el que debemos habilitar los CORS para que cualquier origen pueda acceder. \u00bfEntonces que podemos hacer? Una de las soluciones es solicitar un API-KEY que venga en los headers de la solicitud. Validamos que sea correcto, y si es correcto podemos continuar con nuestra petici\u00f3n. \u00bfTe imaginas c\u00f3mo?","title":"Asignaci\u00f3n de API-KEY a nuestro REST-API"},{"location":"apiKey/#reto","text":"Este es el reto de nuestro proyecto. Ya te di todas las bases acerca de c\u00f3mo crear el API-REST y de c\u00f3mo funciona todo nuestro c\u00f3digo, es tu turno de poner en pr\u00e1ctica lo visto anteriormente para que le asignes la validaci\u00f3n por API-KEY a nuestro proyecto PISTA: \u00a1\u00a1\u00a1\u00a1USA LOS MIDDLEWARE!!!! \u00a1\u00a1Cuando tengas todo listo, utiliza POSTMAN para realizar las pruebas!! \u00a1No olvides poner en los headers el api-key que configuraste! \u00a1\u00a1Cualquier problema que se te presente, no dudes en escribirme!!","title":"Reto"},{"location":"consumo/","text":"Pr\u00f3ximamente...","title":"7. Consumo del API (Front-end)"},{"location":"consumo/#proximamente","text":"","title":"Pr\u00f3ximamente..."},{"location":"database/","text":"Creaci\u00f3n de una base de datos en Azure, modificaci\u00f3n del API para trabar con DB y vinculaci\u00f3n con el API Creaci\u00f3n de un Servidor en Azure Para hacer la creaci\u00f3n de un servidor de Azure, lo primero que tenemos que hacer es tener una cuenta en portal.azure.com. Yo por ejemplo, cre\u00e9 mi cuenta con mi correo estudiantil, el cual me otorga $100 d\u00f3lares para poder ocupar en los servicios de Azure. Una vez con nuestra cuenta logueada, vamos a poner en el buscador \"Servidores de Azure Database for MySQL\" y haremos clic en este que aparece en la imagen Nos aparecer\u00e1 la siguiente venta y haremos clic en \"Crear Azure Database para el servidor MySQL\" Nos aparecer\u00e1 una ventana como la siguiente y vamos a seleccionar en el apartado Tipo de recurso la opci\u00f3n de \"Servidor flexible\" y vamos a dar clic en \"crear\" Configuraci\u00f3n del servidor Se nos abrir\u00e1 una ventana en donde realizaremos las siguientes configuraciones. Detalles del proyecto En este apartado seleccionaremos \"Azure for Students\" en el apartado de Suscripci\u00f3n y en Grupo de recursos seleccionaremos \"DemoWeb\", el cual ya hab\u00edamos creado con anterioridad en la secci\u00f3n 4 de este tutorial. Detalles del servidor Asignaremos el Nombre del servidor , en este caso yo le pondr\u00e9 por nombre \"rest-api-server\", las dem\u00e1s configuraciones las colocaremos como se muestra en la imagen, y haremos clic en \"Configurar servidor\" Se nos abrir\u00e1 otra ventana NOTA IMPORTANTE: CREAR UN SERVIDOR DE ESTE TIPO TIENE UN COSTO MENSUAL, NOSOTROS LO VAMOS A CONFIGURAR TRATANDO DE HACERLO LO MAS ECON\u00d3MICO POSIBLE, COMO SOLO ES UN PROYECTO CON FINES DE APRENDIZAJE, NO NECESITAMOS MUCHOS RECURSOS. AUN AS\u00cd, TE VOY A COMPARTIR ESTE PROYECTO FUNCIONANDO PARA QUE TU PUEDAS REALIZAR TUS PROPIAS PRUEBAS, SI LO REVISAS DESPUES DE UN A\u00d1O A PARTIR DE QUE SE REALIZ\u00d3 ESTE PROYECTO (02/06/2022) ES PROBABLE QUE LOS CREDITOS QUE NOS PROPORCION\u00d3 AZURE YA EST\u00c9N VENCIDOS Y POR LO TANTO EL SERVIDOR YA NO EST\u00c9 ACTIVO Proceso En este apartado solo modificaremos el Tama\u00f1o de proceso y seleccionaremos la opci\u00f3n \"Standard_B1s(1 n\u00facleo virtual, 1 memoria GiB, 400 IPOS m\u00e1xima)\" Almacenamiento En Storage size (in GiB) Seleccionaremos \"20\" y en IOPS pondremos \"360\" Y listo, las dem\u00e1s configuraciones las dejaremos por defecto. Y haremos clic en \"Guardar\" \u00a1Podemos observar que conseguimos hacer un poco m\u00e1s barato el costo del servidor! Cuenta de administrador Por \u00faltimo, vamos a configurar el usuario de nuestro servidor para poder acceder a \u00e9ste. En Nombre de usuario de administrador vamos a colocar un nombre para nuestro administrador, en este caso voy a colocar \"root1\" y vamos a crear una contrase\u00f1a. Y haremos clic en \" Siguiente\". Es importante guardas estos datos porque los vamos a estar utilizando m\u00e1s adelante para poder conectarnos a nuestro servidor Redes En esta ventana bajaremos hasta el apartado \"Reglas de firewall\" Reglas de firewall Vamos seleccionar la opci\u00f3n \"Permitir\u201d acceso p\u00fablico a este servidor desde cualquier servicio de Azure dentro de Azure\" y hacer clic en \"+ Agregar direcci\u00f3n IP del cliente actual\" Nos aseguramos de que se haya agregado en la tabla de abajo Las dem\u00e1s configuraciones las dejaremos por defecto y haremos clic en \"Revisar y crear\" Nos aparecer\u00e1 una venta como esta y haremos con en \"crear\" Posteriormente la implementaci\u00f3n de nuestro servidor comenzar\u00e1, aqu\u00ed debemos esperar unos minutos a que termine la implementaci\u00f3n Una vez terminada la implementaci\u00f3n, nos aparecer\u00e1 una ventana como la siguiente, y haremos clic sobre \" Ir al recurso\" Des habilitaci\u00f3n de la aplicaci\u00f3n de SSL La siguiente informaci\u00f3n fue sacada directamente de la documentaci\u00f3n de Microsoft *\"El servidor flexible de Azure Database for MySQL admite la conexi\u00f3n de las aplicaciones cliente al servidor MySQL mediante el cifrado de la Capa de sockets seguros (SSL) con la Seguridad de la capa de transporte (TLS). TLS es un protocolo est\u00e1ndar del sector que garantiza conexiones de red cifradas entre el servidor de bases de datos y las aplicaciones cliente, lo que le permite ajustarse a los requisitos de cumplimiento. Si la aplicaci\u00f3n cliente no admite conexiones cifradas, tendr\u00e1 que deshabilitar la obligatoriedad de conexiones cifradas en el servidor flexible. Para deshabilitar la obligatoriedad de conexiones cifradas, debe establecer el par\u00e1metro de servidor require_secure_transport en OFF\"* Para m\u00e1s informaci\u00f3n acerca de SSL, te invito a pasar a la p\u00e1gina de Microsoft para que te informes mas LINK Como ya lo leyeron arriba, nuestra aplicaci\u00f3n cliente no va a admitir conexiones cifradas, por lo tanto tenemos que deshabilitarlas, para esto dentro del recurso de nuestro servidor vamos a ir a la barra del lado izquierdo y buscaremos la opci\u00f3n Par\u00e1metros del servidor y haremos clic sobre \u00e9ste Se nos abrir\u00e1 una ventana y en el buscador colocaremos \"require_secure_transport\", cambiaremos la opci\u00f3n a \"OFF\" y daremos clic en \"Guardar\" Esperemos nuevamente que termine la implementaci\u00f3n y una vez terminada, vamos a ir a la opci\u00f3n de la barra de lado izquierdo que dice \"Informaci\u00f3n general\" vamos a dar clic y se nos abrir\u00e1 una ventana como esta: De aqu\u00ed vamos a copiar el Nombre del servidor que es el que vamos a estar utilizando para poder conectarnos a nuestro servidor. En este caso el enlace para el servidor que montamos es: rest-api-server.mysql.database.azure.com estamos listo para crear nuestra base de datos!!! Creaci\u00f3n de base de datos y tabla Una vez implementados nuestros cambios, vamos a hacer clic en \" Ir al recurso\" y una vez aqu\u00ed, vamos a acceder a la terminal dentro de nuestro portal de Azure, para esto haremos clic sobre este icono ubicado en la parte superior de nuestra ventana En la parte de abajo nos aparecer\u00e1 una ventana como esta y haremos clic sobre \" Crear almacenamiento\" Esperamos a que termine de cargar y finalmente nos aparecer\u00e1 una ventana como esta: \u00a1Muy bien! Ahora s\u00ed estamos listos para crear nuestra base de datos. Para crear nuestra base de datos tenemos dos opciones, usar la terminal que nos ofrece el propio portal de Azure, o hacer uso de MySQL Workbench . Nosotros en esta ocasi\u00f3n vamos a utilizar la terminal de Azure, pero si tu decides hacerla haciendo uso de MySQL Workbench, aqu\u00ed te dejo la DOCUMENTACI\u00d3N necesaria de parte de Microsoft para realizar la conexi\u00f3n Para crear nuestra base de datos primero realizaremos la conexi\u00f3n al servidor con MySQL, para esto vamos a ingresar la siguiente l\u00ednea de c\u00f3digo en nuestra terminal, en donde host es el nombre del servidor (que copiamos anteriormente) y user el nombre del administrador que configuramos cuando creamos el servidor mysql --host=rest-api-server.mysql.database.azure.com --user=root1 -p Despu\u00e9s nos va a pedir nuestra contrase\u00f1a, aqu\u00ed es muy importante notar, que vamos a escribir nuestra contrase\u00f1a pero no se va a ver que estamos escribiendo, es decir el curso seguir\u00e1 igual, pero en realidad s\u00ed estamos escribiendo. Una vez insertada nuestra contrase\u00f1a correctamente vamos a presionar \"enter\" y nos aparecer\u00e1 algo as\u00ed Para crear nuestra base de datos insertaremos el siguiente comando, donde \"baseDeDatosDemoWeb\" es el nombre que decid\u00ed para mi base datos, pueden sustituirlo por el nombre de su preferencia create database baseDeDatosDemoWeb; Vamos a recibir esta respuesta Ahora debemos hacer uso de nuestra base de datos, para esto vamos a insertar el siguiente comando, en donde baseDeDatosDemoWeb, es el nombre de la base de datos que queremos utilizar: USE baseDeDatosDemoWeb; Vamos a recibir la siguiente respuesta Una vez dentro de nuestra base de datos, vamos a crear dentro una tabla, para esto vamos a insertar el siguiente c\u00f3digo. Aqu\u00ed es muy importante que el nombre de los campo coincidan con los nombres que asignamos en el Schema de nuestra definici\u00f3n . Por otro lado \"persona\" es el nombre que decid\u00ed para la tabla, ustedes pueden poner el nombre de su preferencia. CREATE TABLE personas ( id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY, Nombre VARCHAR(20), Apellido VARCHAR(20), Edad INT UNSIGNED, Mail VARCHAR(40), Celular BIGINT UNSIGNED ); Vamos a recibir la siguiente respuesta: Y ahora vamos a insertar unos datos de forma manual, para tener algo con que comenzar, posteriormente todo lo haremos directamente desde nuestro REST-API. Para insertar los datos vamos a escribir el siguiente c\u00f3digo en nuestro terminal INSERT INTO personas (Nombre, Apellido, Edad, Mail,Celular) VALUES ('Roberto', 'Carlos', 25, 'roberto@correo.com', 2222222222), ('Carlos', 'Guzman', 24, 'carlos@correo.com',6666666666), ('Maite', 'Cruz', 23, 'maite@correo.com', 1111111111); Recibiremos una respuesta como esta Por \u00faltimo, verificamos los datos que introducimos, para esto utilizamos el comando SELECT * from personas; Recibiremos esta respuesta \u00a1\u00a1Y ahora s\u00ed!! Tenemos nuestro servidor, nuestra base de datos y nuestra tabla trabajando perfectamente. Ahora lo que sigue es modificar nuestro c\u00f3digo del API, para que pueda tener acceso a nuestro servidor Cambios en el c\u00f3digo de nuestro REST-API A\u00f1adir dependencias Como bien sabemos, anteriormente ten\u00edamos nuestra \"base de datos\" en un arreglo dentro de nuestra aplicaci\u00f3n, pero como ahora s\u00ed tenemos una base de datos, a la cual conectar nuestro REST API, tenemos que hacer unos cambios en nuestro c\u00f3digo para poder conectarnos e interactuar con \u00e9sta. Antes de comenzar, debemos instalar en nuestro proyecto de VScode la dependencia de MySQL, lo cual vamos a hacer poniendo el siguiente comando en la terminal dentro de nuestro proyecto: npm i mysql -s Instalamos doteev que es una dependencia de node que carga las variables de entorno desde un archivo .env en process.env npm i dotenv -s C\u00f3digo Vamos a partir de nuestro proyecto creado anteriormente, y simplemente haremos algunas modificaciones. Si no tiene el proyecto, aqu\u00ed te dejo el repositorio para que vayas a descargarlo LINK Abrimos nuestro proyecto en VSCode En nuestro proyecto, en el mismo nivel que la carpeta app , vamos a crear un archivo nuevo y lo vamos a nombrar \".env\" . Tambi\u00e9n, nuevamente en el mismo nivel que la carpeta app vamos a crear una nueva carpeta, la cual nombraremos \"config\" y dentro de esta carpeta vamos a crear un archivo llamado \"mysql.js\" esto haciendo referencia a que nos servir\u00e1 para la conexi\u00f3n con la base de datos de MySQL. Quedando al final de la siguiente forma, los archivos remarcados en color verde son los que acabamos de agregar: Abrimos ahora el archivo .env, en este archivo van a ir todos los datos necesario para conectarnos a nuestra base de datos El archivo .env permite personalizar las variables de entorno de trabajo individuales. Puesto que el archivo .env est\u00e1 oculto El uso de variables de entorno, o environment, en las aplicaciones web es importante para la separaci\u00f3n del c\u00f3digo por responsabilidades, no debemos mezclar el c\u00f3digo de la aplicaci\u00f3n con los valores de configuraci\u00f3n. Las variables de configuraci\u00f3n cambiar\u00e1n generalmente seg\u00fan el entorno de ejecuci\u00f3n, es decir, cuando una aplicaci\u00f3n est\u00e1 siendo ejecutada en distintos servidores. Lo que es importante es que estos archivos no se encuentren al alcance de los usuarios, por lo que nunca deber\u00edan estar dentro de la carpeta de publicaci\u00f3n, sino en alg\u00fan directorio por encima en el servidor. Es decir, se colocar\u00e1 en la ra\u00edz del proyecto, pero nunca dentro de la carpeta ra\u00edz de publicaci\u00f3n, pues si estuvieran all\u00ed los usuarios podr\u00edan acceder a esos valores componiendo la ruta como \"example.com/.env\". Obviamente, los valores de configuraci\u00f3n deseamos que est\u00e9n seguros, por lo que no deben ser accesibles por el p\u00fablico en general. En este archivo \".env\" vamos a agregar las siguientes l\u00edneas DB_CONN=rest-api-server.mysql.database.azure.com DB_USER=root1 DB_PASSWORD=rest-api246 DB_DATABASE=basededatosdemoweb DB_PORT=3306 Se estar\u00e1n preguntando de donde obtuve esos datos, para obtener los datos de la conexi\u00f3n a nuestra base de datos. Tenemos que ir al servidor que creamos anteriormente dentro Azure. Par eso tenemos que visitar portal.azure.com , ah\u00ed vamos a buscar nuestro servidor creado y daremos clic en \u00e9ste Nos desplegar\u00e1 una ventana y buscaremos en la barra lateral derecha el apartado de \"Cadenas de conexi\u00f3n\" Aqu\u00ed nosotros copiaremos por ejemplo la de Node.js La cual nos dar\u00e1 algo como esto: var conn=mysql.createConnection({ host:\"rest-api-server.mysql.database.azure.com\", user:\"root1\", password:\"{your_password}\", database:\"{your_database}\", port:3306, ssl:{ca:fs.readFileSync(\"{ca-cert filename}\")}}); Como nosotros no vamos a hacer la conexi\u00f3n directa, sino que vamos a hacer por medio de variables de entorno, entonces de aqu\u00ed vamos a ir copiando los valores uno a uno e \u00edrselos asignado a las constantes que pusimos en el archivo \".env\". Ahora recordemos que nosotros eliminamos la autenticaci\u00f3n por SSL por lo que no es necesario agregar esa variable. Los campos password lo obtuvimos al momento de crear nuestro servidor, y database es el nombre de la base de datos que nosotros creamos. Posterior a esto, en el archivo \"mysql.js\" que creamos vamos a pegar el siguiente c\u00f3digo, este nos servir\u00e1 para realizar la conexi\u00f3n con la BD const mysql = require('mysql');//Utilizo el m\u00f3dulo de mysql p //Creo una funci\u00f3n para realizar la conexi\u00f3n de la base de datos const dbConnect = () =>{ /*creo un objeto con los par\u00e1metros necesarios para realizar la conexi\u00f3n a la db, noten que lo realizo con los valores que a\u00f1adimos en el archivo .env*/ conn= mysql.createConnection({ host:process.env.DB_CONN, user:process.env.DB_USER, password:process.env.DB_PASSWORD, database:process.env.DB_DATABASE, port:process.env.DB_PORT }) //con los datos del objeto, intentamos hacer la conexi\u00f3n a la base de datos conn.connect(error=>{ // si hay error en la conexi\u00f3n if(error) throw {error: \"**** ERROR DE CONEXION ****\"} //si la conexi\u00f3n fue correcta console.log(\"**** CONEXION CORRECTA ****\"); }) } //exportamos nuestra funci\u00f3n para llamarla en el index module.exports={dbConnect} Y finalmente en el archivo index.js vamos a agregar en las cabeceras las siguientes l\u00edneas require('dotenv').config() const {dbConnect}=require('./config/mysql')// importamos la funci\u00f3n dbConnect del archivo mysql.js Y en la parte de hasta abajo, antes de realizar el app.listen al puerto vamos a agregar //llamamos a la funci\u00f3n que realiza la conexi\u00f3n con la DB dbConnect() Y as\u00ed es, solo con tres l\u00edneas en nuestro \u00edndex, creamos la conexi\u00f3n a nuestra base de datos. De todas formas, el c\u00f3digo completo en el archivo de index.js es el siguiente: const express = require('express'); // Utilizo el m\u00f3dulo de express de Node const path = require('path'); // Utilizo el m\u00f3dulo path de Node const bodyParser = require('body-parser') // Utilizo el modulo de body parser const app = express(); // Genero mi aplicaci\u00f3n de express simplemente llamando al constructor express() const endPoints = require('./app/routers/personas')/*Importo el modulo(en este caso endPoint) que exporte desde la ruta ./app/routers/personas */ const cors = require('cors')//Utilizo el m\u00f3dulo de cors require('dotenv').config() const {dbConnect}=require('./config/mysql')// importamos la funcion dbConnect del archivo mysql.js app.use(cors());//le damos acceso a nuestro API desde cualquier 'origen' //Route \"Pagina principal\" al momento de conectarse al API, con un m\u00e9todo GET que el navegador hace por default app.get('/', (req, res)=>{ res.send(\"Bienvenido a mi API\"); }) //Middleware //Body Parser (Para pasar a json los endpoint tipo post), se ejecuta antes de llegar al siguiente Middleware app.use(bodyParser.urlencoded({extended: true})); app.use(bodyParser.json()); //Middleware (registra una ruta) y ejecuta lo que viene dentro de endPoints app.use('/personas', endPoints) /*Si tuvieramos otra ruta en nuestra api como por ejemplo '/objetos', debemos crear las respectivas hojas de las carpetas controllers y routers con el mismo nombre 'objetos'*/ //llamamos a la funci\u00f3n que realiza la conexi\u00f3n con la DB dbConnect() /* constante para nuestro puerto, es un una condici\u00f3n OR para el caso de desarrollo en alg\u00fan servicio o desarrollo local (nuestro caso) */ const port = process.env.port || 8080; app.listen(port, () =>console.log(`Escuchando en el puerto ${port}`)) Guardamos los cambios y corremos nuestra aplicaci\u00f3n, ya saben para esto en la terminal escribimos el comando npm run serve Y si todo sale bien, nos aparecer\u00e1 en consola un mensaje como este, lo cual indica que hicimos una conexi\u00f3n correcta a nuestra base de datos Ahora simplemente en nuestro archivo personas.j dentro de la carpeta de controllers , vamos a realizar algunas modificaciones, porque, recordemos que ya no vamos a hacer las solicitudes simplemente con un array interno, sino que las haremos directamente en la base de datos. En este archivo, cambiaremos el contenido de cada funci\u00f3n, porque antes insert\u00e1bamos datos en un array, ahora tenemos que cambiar esto por comandos y validaciones de SQL. El c\u00f3digo que vamos a insertar es el siguiente. El c\u00f3digo viene con sus respectivos comentarios para mayor entendimiento del mismo const { response } = require('express'); const { request } = require('express'); //Obtener todas las personas de la lista const obtenerPersonas = [(request, response)=>{ //creo el comando para seleccionar todas los elementos mi tabla personas y lo guardo en sql const sql = 'SELECT * FROM personas'; //Hago la conexi\u00f3n con mi base de datos conn.query(sql, (error, results) => { //Si se genera un error con la bd lo lanzamos if (error) throw error; // Sino se genera error, verificamos que venga algo en la respuesta, es decir que el haya al menos una persona registrada if (results.length > 0) { /*Si existen personas,Mandamos todas las persona registradas en la respuesta, aqu\u00ed ya se realiz\u00f3 la sentencia de sql*/ response.json(results); } else { //Sino existe ninguna persona registrada imprimimos el mensaje: response.status(415).json({error: \"No existe ninguna persona registrada\"}); } }); }] //Obtener una personas de la lista de acuerdo a su ID const obtenerPersona =[(request,response)=>{ /*recupero el id de la persona haciendo un de-structur. La idea es crear una variable llamada id, que est\u00e1 contenida con el mismo nombre id dentro de parms*/ const {id} = request.params //creo el comando para seleccionar la persona con el id de mi tabla personas y lo guardo en sql const sql = `SELECT * FROM personas WHERE id = ${id}`; //Hago la conexi\u00f3n con mi base de datos conn.query(sql, (error, results) => { //Si se genera un error con la bd lo lanzamos if (error) throw error; // Sino se genera error, verificamos que venga algo en la respuesta, es decir que el id exista if (results.length > 0) { // Si el id existe, mandamos en la respuesta los datos de la persona, aqu\u00ed ya se realiz\u00f3 la sentencia de sql response.json(results); } else { //Sino existe el id imprimimos el mensaje: response.status(410).json({error: \"Este id no existe\"}); } }); }] //A\u00f1adir una nueva persona a la lista const a\u00f1adirPersona = [(request,response)=>{ /*Todo esto se ejecuta solo si los datos fueron validados. Es decir, validarDatos dentro de /validator/personas.js continu\u00f3 con next()*/ //creo el comando para seleccionar para a\u00f1adir una persona en mi tabla personas y lo guardo en sql const sql = `INSERT INTO personas SET ?` //Crea una variable de tipo objeto, llamada nuevaPersona, con los datos mandados en el body dentro de request const nuevaPersona = { Nombre: request.body.Nombre, Apellido: request.body.Apellido, Edad: request.body.Edad, Mail: request.body.Mail, Celular: request.body.Celular } //Hago la conexi\u00f3n con mi base de datos conn.query(sql,nuevaPersona, (error) => { //Si se genera un error con la bd lo lanzamos if (error) throw error; /* Sino se genera error, mando en mi respuesta los de la persona creada, aqu\u00ed ya se realiz\u00f3 la sentencia de sql,pero para mandar los datos de la persona creada primero solicito el id que le asign\u00f3 con el siguiente comando*/ sqlId ='SELECT @@identity AS id' //Hago la conexi\u00f3n con mi base de datos conn.query(sqlId,(error,results)=>{ //Si se genera un error con la bd lo lanzamos if (error) throw error; // Sino se genera error accedo al id que viene que viene en la posici\u00f3n cero de resultados neWId=results[0].id //a mi objeto nuevo persona le agrego el id nuevaPersona.id=neWId // Ahora s\u00ed mando como respuesta los datos de la persona que se agreg\u00f3 response.json(nuevaPersona) }) }); }] //Actualizar una nueva persona de la lista const actualizarPersona = [ (request,response)=>{ /*Todo esto se ejecuta solo si los datos fueron validados. Es decir, validarDatos dentro de /validator/personas.js continu\u00f3 con next() */ /*recupero el id de la persona haciendo un de-structur. La idea es crear una variable llamada id, que est\u00e1 contenida con el mismo nombre id dentro de parms*/ const {id} = request.params //creo el comando para seleccionar la persona con el id de mi tabla personas y lo guardo en sql const sql = `SELECT * FROM personas WHERE id = ${id}`; //Hago la conexi\u00f3n con mi base de datos conn.query(sql, (error, results) => { //Si se genera un error con la bd lo lanzamos if (error) throw error; // Sino se genera error, verificamos que venga algo en la respuesta, es decir que el id exista if (results.length > 0) { /*Si el id existe, almaceno en variables todos los valores que provienen del body (desestructuro) */ const {Nombre,Apellido,Edad,Mail,Celular} = request.body; /* Si el id existe, podemos modificar los datos de la persona, entonces guardamos el comando para modificar en sqlUpdate*/ const sqlUpdate = `UPDATE personas SET Nombre = '${Nombre}', Apellido = '${Apellido}', Edad = '${Edad}', Mail = '${Mail}', Celular = '${Celular}' WHERE id = ${id}; ` //Hago la conexi\u00f3n con mi base de datos conn.query(sqlUpdate,error => { //Si se genera un error con la bd lo lanzamos if (error) throw error; /* Sino se genera error, mando en mi respuesta los de la persona modificados, aqu\u00ed ya se realiz\u00f3 la sentencia de sql */ response.json({id,Nombre,Apellido,Edad,Mail,Celular}); }); } else { //Sino existe el id imprimimos el mensaje: response.status(410).json({error: \"Este id no existe\"}); } }); }] const eliminarPersona = [(request,response)=>{ /*recupero el id de la persona haciendo un de-structur. La idea es crear una variable llamada id, que est\u00e1 contenida con el mismo nombre id dentro de parms*/ const {id} = request.params //creo el comando para seleccionar la persona con el id de mi tabla personas y lo guardo en sql const sql = `SELECT * FROM personas WHERE id = ${id}`; //Hago la conexi\u00f3n con mi base de datos conn.query(sql, (error, results) => { //Si se genera un error con la bd lo lanzamos if (error) throw error; // Sino se genera error, verificamos que venga algo en la respuesta, es decir que el id exista if (results.length > 0) { // Si el id existe, lo podemos eliminar., entonces guardamos el comando para eliminar en: sqlDelete const sqlDelete = `DELETE FROM personas WHERE id = ${id};` //Hago la conexi\u00f3n con mi base de datos conn.query(sqlDelete,error => { //Si se genera un error con la bd lo lanzamos if (error) throw error; /* Sino se genera error, mando en mi respuesta el id de la persona eliminada, aqu\u00ed ya se realiz\u00f3 la sentencia de sqlDelete */ response.json(id); }); } else { //Sino existe el id imprimimos el mensaje response.status(410).json({error: \"Este id no existe\"}); } }); }] //exporto las funciones hacia mi ruta /routers/personas.js module.exports = {obtenerPersonas, obtenerPersona,a\u00f1adirPersona, actualizarPersona, eliminarPersona} Y listo!! \u00a1\u00a1\u00a1Tenemos nuestro REST-API terminado y conectado a una base de datos en la nube de Azure!!! \u00a1Fenomenal! . \u00a1\u00a1\u00a1\u00a1Aqu\u00ed te voy a dejar el repositorio con el c\u00f3digo completo y listo para ser ejecutado!!!! ------>>>> LINK DEL REPOSITORIO COMPLETO LINK Validaci\u00f3n de los END-POINTS utilizando POSTMAN Lo siguiente es realizar nuestras pruebas, para verificar que todo est\u00e9 funcionando correctamente. Para esto te voy a dejar nuevamente un archivo tipo JSON para que podamos realizar las validaciones en POSTMAN VALIDACIONES Ingresaremos a POSTMAN, pero antes, verifiquemos el estado actual de la Tabla personas dentro de nuestra base de datos que creamos con anterioridad. Para esto vamos a ir al portal de Azure, abriremos la terminal y nos conectaremos a nuestro servidor. Una vez dentro de nuestro servidor, utilizaremos el comando USE basededatosdemoweb Posteriormente utilizaremos SELECT * FROM personas Y obtendremos esta respuesta, este es el estado actual de nuestra tabla personas, que ser\u00eda m\u00e1s o menos as\u00ed. Ahora s\u00ed, iremos a postman y con el m\u00e9todo GET tendr\u00eda que devolvernos los mismos datos que nuestra base de datos 1.- Prueba del m\u00e9todo GET que nos devuelve todas las personas \u00a1\u00a1Como pueden observar, efectivamente nos devuelve los mismos datos que nuestro base de datos!! Estamos haci\u00e9ndolo de forma correcta 2.- Prueba del m\u00e9todo GET que nos devuelve una persona por su ID, si ponemos, por ejemplo, el id No 2. Seg\u00fan nuestra base de datos, tendr\u00eda que devolvernos el API todos los datos de Carlos Guzm\u00e1n. Hacemos la petici\u00f3n en POSTMAN Efectivamente, nos devolvi\u00f3 los resultados esperados. 3.- Probemos ahora con el m\u00e9todo POST. Agregamos los datos en el body seg\u00fan nuestra definic\u00f3n y en postman obtenemos la siguiente respuesta Ahora verificamos en nuestra base de datos, que se haya a\u00f1adido correctamente la persona, para esto nuevamente en la terminal de Azure escribiremos SELECT * FROM personas \u00a1\u00a1\u00a1\u00a1Y podemos observar como en el registro con id=5 a\u00f1adi\u00f3 los datos que le mandamos desde el API!!!! Hasta ahora todo funciona muy bien. Intentemos a\u00f1adir una persona, con un dato faltante en el body Como lo esper\u00e1bamos nos arroja un error, por lo tanto, nuestras validaciones est\u00e1n funcionando correctamente 4.- Probemos ahora con el m\u00e9todo PUT para cambiar los datos de una persona, intentaremos cambiar los datos del registro 5, que intencionalmente los puse repetidos para que podamos probar nuestro m\u00e9todo PUT. Ponemos los datos en el body de acuerdo con nuestra definic\u00f3n y obtenemos la siguiente respuesta Verificamos nuevamente en nuestra base de datos, con el comando sql SELECT * FROM personas Y en efecto, nos modific\u00f3 correctamente los datos 5.- Finalmente probaremos el eliminar una persona, para esto, eliminaremos a la persona con el id=5. Esta es la respuesta obtenida de postman Por \u00faltimo, verificamos nuevamente en nuestra base de datos Y efectivamente borr\u00f3 los datos de esta persona Siguientes pasos \u00bfQu\u00e9 sigue ahora? Vamos a subir nuestro nuevo REST-API en un App Service de Azure, para que podamos acceder a nuestro API desde cualquier lado, pero ya no lo haremos paso a paso, puesto que esto ya lo hicimos anteriormente, sino viste esa parte del tutorial o ya olvidaste los pasos, aqu\u00ed te dejo el ENLACE para que puedas implementar este REST-API en la nube de Azure. Yo ya implement\u00e9 esto en la nube de AZURE, este es el enlace obtenido. \u00a1Te dejo por aqu\u00ed el link para que puedas probarlo tu mismo! LINK ----------------------->>>>>>>>>>>>>> https://personasapi-db.azurewebsites.net Ahora, te invito a seguir con la siguiente parte del tutorial, en donde a\u00f1adiremos un API-KEY a nuestro REST-API para que podamos tener un mejor control de \u00e9sta","title":"5. Creaci\u00f3n de una base de datos en Azure, modificaci\u00f3n del API para trabar con DB y vinculaci\u00f3n con el API"},{"location":"database/#creacion-de-una-base-de-datos-en-azure-modificacion-del-api-para-trabar-con-db-y-vinculacion-con-el-api","text":"","title":"Creaci\u00f3n de una base de datos en Azure, modificaci\u00f3n del API para trabar con DB y vinculaci\u00f3n con el API"},{"location":"database/#creacion-de-un-servidor-en-azure","text":"Para hacer la creaci\u00f3n de un servidor de Azure, lo primero que tenemos que hacer es tener una cuenta en portal.azure.com. Yo por ejemplo, cre\u00e9 mi cuenta con mi correo estudiantil, el cual me otorga $100 d\u00f3lares para poder ocupar en los servicios de Azure. Una vez con nuestra cuenta logueada, vamos a poner en el buscador \"Servidores de Azure Database for MySQL\" y haremos clic en este que aparece en la imagen Nos aparecer\u00e1 la siguiente venta y haremos clic en \"Crear Azure Database para el servidor MySQL\" Nos aparecer\u00e1 una ventana como la siguiente y vamos a seleccionar en el apartado Tipo de recurso la opci\u00f3n de \"Servidor flexible\" y vamos a dar clic en \"crear\"","title":"Creaci\u00f3n de un Servidor en Azure"},{"location":"database/#configuracion-del-servidor","text":"Se nos abrir\u00e1 una ventana en donde realizaremos las siguientes configuraciones.","title":"Configuraci\u00f3n del servidor"},{"location":"database/#detalles-del-proyecto","text":"En este apartado seleccionaremos \"Azure for Students\" en el apartado de Suscripci\u00f3n y en Grupo de recursos seleccionaremos \"DemoWeb\", el cual ya hab\u00edamos creado con anterioridad en la secci\u00f3n 4 de este tutorial.","title":"Detalles del proyecto"},{"location":"database/#detalles-del-servidor","text":"Asignaremos el Nombre del servidor , en este caso yo le pondr\u00e9 por nombre \"rest-api-server\", las dem\u00e1s configuraciones las colocaremos como se muestra en la imagen, y haremos clic en \"Configurar servidor\" Se nos abrir\u00e1 otra ventana NOTA IMPORTANTE: CREAR UN SERVIDOR DE ESTE TIPO TIENE UN COSTO MENSUAL, NOSOTROS LO VAMOS A CONFIGURAR TRATANDO DE HACERLO LO MAS ECON\u00d3MICO POSIBLE, COMO SOLO ES UN PROYECTO CON FINES DE APRENDIZAJE, NO NECESITAMOS MUCHOS RECURSOS. AUN AS\u00cd, TE VOY A COMPARTIR ESTE PROYECTO FUNCIONANDO PARA QUE TU PUEDAS REALIZAR TUS PROPIAS PRUEBAS, SI LO REVISAS DESPUES DE UN A\u00d1O A PARTIR DE QUE SE REALIZ\u00d3 ESTE PROYECTO (02/06/2022) ES PROBABLE QUE LOS CREDITOS QUE NOS PROPORCION\u00d3 AZURE YA EST\u00c9N VENCIDOS Y POR LO TANTO EL SERVIDOR YA NO EST\u00c9 ACTIVO","title":"Detalles del servidor"},{"location":"database/#proceso","text":"En este apartado solo modificaremos el Tama\u00f1o de proceso y seleccionaremos la opci\u00f3n \"Standard_B1s(1 n\u00facleo virtual, 1 memoria GiB, 400 IPOS m\u00e1xima)\"","title":"Proceso"},{"location":"database/#almacenamiento","text":"En Storage size (in GiB) Seleccionaremos \"20\" y en IOPS pondremos \"360\" Y listo, las dem\u00e1s configuraciones las dejaremos por defecto. Y haremos clic en \"Guardar\" \u00a1Podemos observar que conseguimos hacer un poco m\u00e1s barato el costo del servidor!","title":"Almacenamiento"},{"location":"database/#cuenta-de-administrador","text":"Por \u00faltimo, vamos a configurar el usuario de nuestro servidor para poder acceder a \u00e9ste. En Nombre de usuario de administrador vamos a colocar un nombre para nuestro administrador, en este caso voy a colocar \"root1\" y vamos a crear una contrase\u00f1a. Y haremos clic en \" Siguiente\". Es importante guardas estos datos porque los vamos a estar utilizando m\u00e1s adelante para poder conectarnos a nuestro servidor","title":"Cuenta de administrador"},{"location":"database/#redes","text":"En esta ventana bajaremos hasta el apartado \"Reglas de firewall\"","title":"Redes"},{"location":"database/#reglas-de-firewall","text":"Vamos seleccionar la opci\u00f3n \"Permitir\u201d acceso p\u00fablico a este servidor desde cualquier servicio de Azure dentro de Azure\" y hacer clic en \"+ Agregar direcci\u00f3n IP del cliente actual\" Nos aseguramos de que se haya agregado en la tabla de abajo Las dem\u00e1s configuraciones las dejaremos por defecto y haremos clic en \"Revisar y crear\" Nos aparecer\u00e1 una venta como esta y haremos con en \"crear\" Posteriormente la implementaci\u00f3n de nuestro servidor comenzar\u00e1, aqu\u00ed debemos esperar unos minutos a que termine la implementaci\u00f3n Una vez terminada la implementaci\u00f3n, nos aparecer\u00e1 una ventana como la siguiente, y haremos clic sobre \" Ir al recurso\"","title":"Reglas de firewall"},{"location":"database/#des-habilitacion-de-la-aplicacion-de-ssl","text":"La siguiente informaci\u00f3n fue sacada directamente de la documentaci\u00f3n de Microsoft *\"El servidor flexible de Azure Database for MySQL admite la conexi\u00f3n de las aplicaciones cliente al servidor MySQL mediante el cifrado de la Capa de sockets seguros (SSL) con la Seguridad de la capa de transporte (TLS). TLS es un protocolo est\u00e1ndar del sector que garantiza conexiones de red cifradas entre el servidor de bases de datos y las aplicaciones cliente, lo que le permite ajustarse a los requisitos de cumplimiento. Si la aplicaci\u00f3n cliente no admite conexiones cifradas, tendr\u00e1 que deshabilitar la obligatoriedad de conexiones cifradas en el servidor flexible. Para deshabilitar la obligatoriedad de conexiones cifradas, debe establecer el par\u00e1metro de servidor require_secure_transport en OFF\"* Para m\u00e1s informaci\u00f3n acerca de SSL, te invito a pasar a la p\u00e1gina de Microsoft para que te informes mas LINK Como ya lo leyeron arriba, nuestra aplicaci\u00f3n cliente no va a admitir conexiones cifradas, por lo tanto tenemos que deshabilitarlas, para esto dentro del recurso de nuestro servidor vamos a ir a la barra del lado izquierdo y buscaremos la opci\u00f3n Par\u00e1metros del servidor y haremos clic sobre \u00e9ste Se nos abrir\u00e1 una ventana y en el buscador colocaremos \"require_secure_transport\", cambiaremos la opci\u00f3n a \"OFF\" y daremos clic en \"Guardar\" Esperemos nuevamente que termine la implementaci\u00f3n y una vez terminada, vamos a ir a la opci\u00f3n de la barra de lado izquierdo que dice \"Informaci\u00f3n general\" vamos a dar clic y se nos abrir\u00e1 una ventana como esta: De aqu\u00ed vamos a copiar el Nombre del servidor que es el que vamos a estar utilizando para poder conectarnos a nuestro servidor. En este caso el enlace para el servidor que montamos es: rest-api-server.mysql.database.azure.com estamos listo para crear nuestra base de datos!!!","title":"Des habilitaci\u00f3n de la aplicaci\u00f3n de SSL"},{"location":"database/#creacion-de-base-de-datos-y-tabla","text":"Una vez implementados nuestros cambios, vamos a hacer clic en \" Ir al recurso\" y una vez aqu\u00ed, vamos a acceder a la terminal dentro de nuestro portal de Azure, para esto haremos clic sobre este icono ubicado en la parte superior de nuestra ventana En la parte de abajo nos aparecer\u00e1 una ventana como esta y haremos clic sobre \" Crear almacenamiento\" Esperamos a que termine de cargar y finalmente nos aparecer\u00e1 una ventana como esta: \u00a1Muy bien! Ahora s\u00ed estamos listos para crear nuestra base de datos. Para crear nuestra base de datos tenemos dos opciones, usar la terminal que nos ofrece el propio portal de Azure, o hacer uso de MySQL Workbench . Nosotros en esta ocasi\u00f3n vamos a utilizar la terminal de Azure, pero si tu decides hacerla haciendo uso de MySQL Workbench, aqu\u00ed te dejo la DOCUMENTACI\u00d3N necesaria de parte de Microsoft para realizar la conexi\u00f3n Para crear nuestra base de datos primero realizaremos la conexi\u00f3n al servidor con MySQL, para esto vamos a ingresar la siguiente l\u00ednea de c\u00f3digo en nuestra terminal, en donde host es el nombre del servidor (que copiamos anteriormente) y user el nombre del administrador que configuramos cuando creamos el servidor mysql --host=rest-api-server.mysql.database.azure.com --user=root1 -p Despu\u00e9s nos va a pedir nuestra contrase\u00f1a, aqu\u00ed es muy importante notar, que vamos a escribir nuestra contrase\u00f1a pero no se va a ver que estamos escribiendo, es decir el curso seguir\u00e1 igual, pero en realidad s\u00ed estamos escribiendo. Una vez insertada nuestra contrase\u00f1a correctamente vamos a presionar \"enter\" y nos aparecer\u00e1 algo as\u00ed Para crear nuestra base de datos insertaremos el siguiente comando, donde \"baseDeDatosDemoWeb\" es el nombre que decid\u00ed para mi base datos, pueden sustituirlo por el nombre de su preferencia create database baseDeDatosDemoWeb; Vamos a recibir esta respuesta Ahora debemos hacer uso de nuestra base de datos, para esto vamos a insertar el siguiente comando, en donde baseDeDatosDemoWeb, es el nombre de la base de datos que queremos utilizar: USE baseDeDatosDemoWeb; Vamos a recibir la siguiente respuesta Una vez dentro de nuestra base de datos, vamos a crear dentro una tabla, para esto vamos a insertar el siguiente c\u00f3digo. Aqu\u00ed es muy importante que el nombre de los campo coincidan con los nombres que asignamos en el Schema de nuestra definici\u00f3n . Por otro lado \"persona\" es el nombre que decid\u00ed para la tabla, ustedes pueden poner el nombre de su preferencia. CREATE TABLE personas ( id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY, Nombre VARCHAR(20), Apellido VARCHAR(20), Edad INT UNSIGNED, Mail VARCHAR(40), Celular BIGINT UNSIGNED ); Vamos a recibir la siguiente respuesta: Y ahora vamos a insertar unos datos de forma manual, para tener algo con que comenzar, posteriormente todo lo haremos directamente desde nuestro REST-API. Para insertar los datos vamos a escribir el siguiente c\u00f3digo en nuestro terminal INSERT INTO personas (Nombre, Apellido, Edad, Mail,Celular) VALUES ('Roberto', 'Carlos', 25, 'roberto@correo.com', 2222222222), ('Carlos', 'Guzman', 24, 'carlos@correo.com',6666666666), ('Maite', 'Cruz', 23, 'maite@correo.com', 1111111111); Recibiremos una respuesta como esta Por \u00faltimo, verificamos los datos que introducimos, para esto utilizamos el comando SELECT * from personas; Recibiremos esta respuesta \u00a1\u00a1Y ahora s\u00ed!! Tenemos nuestro servidor, nuestra base de datos y nuestra tabla trabajando perfectamente. Ahora lo que sigue es modificar nuestro c\u00f3digo del API, para que pueda tener acceso a nuestro servidor","title":"Creaci\u00f3n de base de datos y tabla"},{"location":"database/#cambios-en-el-codigo-de-nuestro-rest-api","text":"","title":"Cambios en el c\u00f3digo de nuestro REST-API"},{"location":"database/#anadir-dependencias","text":"Como bien sabemos, anteriormente ten\u00edamos nuestra \"base de datos\" en un arreglo dentro de nuestra aplicaci\u00f3n, pero como ahora s\u00ed tenemos una base de datos, a la cual conectar nuestro REST API, tenemos que hacer unos cambios en nuestro c\u00f3digo para poder conectarnos e interactuar con \u00e9sta. Antes de comenzar, debemos instalar en nuestro proyecto de VScode la dependencia de MySQL, lo cual vamos a hacer poniendo el siguiente comando en la terminal dentro de nuestro proyecto: npm i mysql -s Instalamos doteev que es una dependencia de node que carga las variables de entorno desde un archivo .env en process.env npm i dotenv -s","title":"A\u00f1adir dependencias"},{"location":"database/#codigo","text":"Vamos a partir de nuestro proyecto creado anteriormente, y simplemente haremos algunas modificaciones. Si no tiene el proyecto, aqu\u00ed te dejo el repositorio para que vayas a descargarlo LINK Abrimos nuestro proyecto en VSCode En nuestro proyecto, en el mismo nivel que la carpeta app , vamos a crear un archivo nuevo y lo vamos a nombrar \".env\" . Tambi\u00e9n, nuevamente en el mismo nivel que la carpeta app vamos a crear una nueva carpeta, la cual nombraremos \"config\" y dentro de esta carpeta vamos a crear un archivo llamado \"mysql.js\" esto haciendo referencia a que nos servir\u00e1 para la conexi\u00f3n con la base de datos de MySQL. Quedando al final de la siguiente forma, los archivos remarcados en color verde son los que acabamos de agregar: Abrimos ahora el archivo .env, en este archivo van a ir todos los datos necesario para conectarnos a nuestra base de datos El archivo .env permite personalizar las variables de entorno de trabajo individuales. Puesto que el archivo .env est\u00e1 oculto El uso de variables de entorno, o environment, en las aplicaciones web es importante para la separaci\u00f3n del c\u00f3digo por responsabilidades, no debemos mezclar el c\u00f3digo de la aplicaci\u00f3n con los valores de configuraci\u00f3n. Las variables de configuraci\u00f3n cambiar\u00e1n generalmente seg\u00fan el entorno de ejecuci\u00f3n, es decir, cuando una aplicaci\u00f3n est\u00e1 siendo ejecutada en distintos servidores. Lo que es importante es que estos archivos no se encuentren al alcance de los usuarios, por lo que nunca deber\u00edan estar dentro de la carpeta de publicaci\u00f3n, sino en alg\u00fan directorio por encima en el servidor. Es decir, se colocar\u00e1 en la ra\u00edz del proyecto, pero nunca dentro de la carpeta ra\u00edz de publicaci\u00f3n, pues si estuvieran all\u00ed los usuarios podr\u00edan acceder a esos valores componiendo la ruta como \"example.com/.env\". Obviamente, los valores de configuraci\u00f3n deseamos que est\u00e9n seguros, por lo que no deben ser accesibles por el p\u00fablico en general. En este archivo \".env\" vamos a agregar las siguientes l\u00edneas DB_CONN=rest-api-server.mysql.database.azure.com DB_USER=root1 DB_PASSWORD=rest-api246 DB_DATABASE=basededatosdemoweb DB_PORT=3306 Se estar\u00e1n preguntando de donde obtuve esos datos, para obtener los datos de la conexi\u00f3n a nuestra base de datos. Tenemos que ir al servidor que creamos anteriormente dentro Azure. Par eso tenemos que visitar portal.azure.com , ah\u00ed vamos a buscar nuestro servidor creado y daremos clic en \u00e9ste Nos desplegar\u00e1 una ventana y buscaremos en la barra lateral derecha el apartado de \"Cadenas de conexi\u00f3n\" Aqu\u00ed nosotros copiaremos por ejemplo la de Node.js La cual nos dar\u00e1 algo como esto: var conn=mysql.createConnection({ host:\"rest-api-server.mysql.database.azure.com\", user:\"root1\", password:\"{your_password}\", database:\"{your_database}\", port:3306, ssl:{ca:fs.readFileSync(\"{ca-cert filename}\")}}); Como nosotros no vamos a hacer la conexi\u00f3n directa, sino que vamos a hacer por medio de variables de entorno, entonces de aqu\u00ed vamos a ir copiando los valores uno a uno e \u00edrselos asignado a las constantes que pusimos en el archivo \".env\". Ahora recordemos que nosotros eliminamos la autenticaci\u00f3n por SSL por lo que no es necesario agregar esa variable. Los campos password lo obtuvimos al momento de crear nuestro servidor, y database es el nombre de la base de datos que nosotros creamos. Posterior a esto, en el archivo \"mysql.js\" que creamos vamos a pegar el siguiente c\u00f3digo, este nos servir\u00e1 para realizar la conexi\u00f3n con la BD const mysql = require('mysql');//Utilizo el m\u00f3dulo de mysql p //Creo una funci\u00f3n para realizar la conexi\u00f3n de la base de datos const dbConnect = () =>{ /*creo un objeto con los par\u00e1metros necesarios para realizar la conexi\u00f3n a la db, noten que lo realizo con los valores que a\u00f1adimos en el archivo .env*/ conn= mysql.createConnection({ host:process.env.DB_CONN, user:process.env.DB_USER, password:process.env.DB_PASSWORD, database:process.env.DB_DATABASE, port:process.env.DB_PORT }) //con los datos del objeto, intentamos hacer la conexi\u00f3n a la base de datos conn.connect(error=>{ // si hay error en la conexi\u00f3n if(error) throw {error: \"**** ERROR DE CONEXION ****\"} //si la conexi\u00f3n fue correcta console.log(\"**** CONEXION CORRECTA ****\"); }) } //exportamos nuestra funci\u00f3n para llamarla en el index module.exports={dbConnect} Y finalmente en el archivo index.js vamos a agregar en las cabeceras las siguientes l\u00edneas require('dotenv').config() const {dbConnect}=require('./config/mysql')// importamos la funci\u00f3n dbConnect del archivo mysql.js Y en la parte de hasta abajo, antes de realizar el app.listen al puerto vamos a agregar //llamamos a la funci\u00f3n que realiza la conexi\u00f3n con la DB dbConnect() Y as\u00ed es, solo con tres l\u00edneas en nuestro \u00edndex, creamos la conexi\u00f3n a nuestra base de datos. De todas formas, el c\u00f3digo completo en el archivo de index.js es el siguiente: const express = require('express'); // Utilizo el m\u00f3dulo de express de Node const path = require('path'); // Utilizo el m\u00f3dulo path de Node const bodyParser = require('body-parser') // Utilizo el modulo de body parser const app = express(); // Genero mi aplicaci\u00f3n de express simplemente llamando al constructor express() const endPoints = require('./app/routers/personas')/*Importo el modulo(en este caso endPoint) que exporte desde la ruta ./app/routers/personas */ const cors = require('cors')//Utilizo el m\u00f3dulo de cors require('dotenv').config() const {dbConnect}=require('./config/mysql')// importamos la funcion dbConnect del archivo mysql.js app.use(cors());//le damos acceso a nuestro API desde cualquier 'origen' //Route \"Pagina principal\" al momento de conectarse al API, con un m\u00e9todo GET que el navegador hace por default app.get('/', (req, res)=>{ res.send(\"Bienvenido a mi API\"); }) //Middleware //Body Parser (Para pasar a json los endpoint tipo post), se ejecuta antes de llegar al siguiente Middleware app.use(bodyParser.urlencoded({extended: true})); app.use(bodyParser.json()); //Middleware (registra una ruta) y ejecuta lo que viene dentro de endPoints app.use('/personas', endPoints) /*Si tuvieramos otra ruta en nuestra api como por ejemplo '/objetos', debemos crear las respectivas hojas de las carpetas controllers y routers con el mismo nombre 'objetos'*/ //llamamos a la funci\u00f3n que realiza la conexi\u00f3n con la DB dbConnect() /* constante para nuestro puerto, es un una condici\u00f3n OR para el caso de desarrollo en alg\u00fan servicio o desarrollo local (nuestro caso) */ const port = process.env.port || 8080; app.listen(port, () =>console.log(`Escuchando en el puerto ${port}`)) Guardamos los cambios y corremos nuestra aplicaci\u00f3n, ya saben para esto en la terminal escribimos el comando npm run serve Y si todo sale bien, nos aparecer\u00e1 en consola un mensaje como este, lo cual indica que hicimos una conexi\u00f3n correcta a nuestra base de datos Ahora simplemente en nuestro archivo personas.j dentro de la carpeta de controllers , vamos a realizar algunas modificaciones, porque, recordemos que ya no vamos a hacer las solicitudes simplemente con un array interno, sino que las haremos directamente en la base de datos. En este archivo, cambiaremos el contenido de cada funci\u00f3n, porque antes insert\u00e1bamos datos en un array, ahora tenemos que cambiar esto por comandos y validaciones de SQL. El c\u00f3digo que vamos a insertar es el siguiente. El c\u00f3digo viene con sus respectivos comentarios para mayor entendimiento del mismo const { response } = require('express'); const { request } = require('express'); //Obtener todas las personas de la lista const obtenerPersonas = [(request, response)=>{ //creo el comando para seleccionar todas los elementos mi tabla personas y lo guardo en sql const sql = 'SELECT * FROM personas'; //Hago la conexi\u00f3n con mi base de datos conn.query(sql, (error, results) => { //Si se genera un error con la bd lo lanzamos if (error) throw error; // Sino se genera error, verificamos que venga algo en la respuesta, es decir que el haya al menos una persona registrada if (results.length > 0) { /*Si existen personas,Mandamos todas las persona registradas en la respuesta, aqu\u00ed ya se realiz\u00f3 la sentencia de sql*/ response.json(results); } else { //Sino existe ninguna persona registrada imprimimos el mensaje: response.status(415).json({error: \"No existe ninguna persona registrada\"}); } }); }] //Obtener una personas de la lista de acuerdo a su ID const obtenerPersona =[(request,response)=>{ /*recupero el id de la persona haciendo un de-structur. La idea es crear una variable llamada id, que est\u00e1 contenida con el mismo nombre id dentro de parms*/ const {id} = request.params //creo el comando para seleccionar la persona con el id de mi tabla personas y lo guardo en sql const sql = `SELECT * FROM personas WHERE id = ${id}`; //Hago la conexi\u00f3n con mi base de datos conn.query(sql, (error, results) => { //Si se genera un error con la bd lo lanzamos if (error) throw error; // Sino se genera error, verificamos que venga algo en la respuesta, es decir que el id exista if (results.length > 0) { // Si el id existe, mandamos en la respuesta los datos de la persona, aqu\u00ed ya se realiz\u00f3 la sentencia de sql response.json(results); } else { //Sino existe el id imprimimos el mensaje: response.status(410).json({error: \"Este id no existe\"}); } }); }] //A\u00f1adir una nueva persona a la lista const a\u00f1adirPersona = [(request,response)=>{ /*Todo esto se ejecuta solo si los datos fueron validados. Es decir, validarDatos dentro de /validator/personas.js continu\u00f3 con next()*/ //creo el comando para seleccionar para a\u00f1adir una persona en mi tabla personas y lo guardo en sql const sql = `INSERT INTO personas SET ?` //Crea una variable de tipo objeto, llamada nuevaPersona, con los datos mandados en el body dentro de request const nuevaPersona = { Nombre: request.body.Nombre, Apellido: request.body.Apellido, Edad: request.body.Edad, Mail: request.body.Mail, Celular: request.body.Celular } //Hago la conexi\u00f3n con mi base de datos conn.query(sql,nuevaPersona, (error) => { //Si se genera un error con la bd lo lanzamos if (error) throw error; /* Sino se genera error, mando en mi respuesta los de la persona creada, aqu\u00ed ya se realiz\u00f3 la sentencia de sql,pero para mandar los datos de la persona creada primero solicito el id que le asign\u00f3 con el siguiente comando*/ sqlId ='SELECT @@identity AS id' //Hago la conexi\u00f3n con mi base de datos conn.query(sqlId,(error,results)=>{ //Si se genera un error con la bd lo lanzamos if (error) throw error; // Sino se genera error accedo al id que viene que viene en la posici\u00f3n cero de resultados neWId=results[0].id //a mi objeto nuevo persona le agrego el id nuevaPersona.id=neWId // Ahora s\u00ed mando como respuesta los datos de la persona que se agreg\u00f3 response.json(nuevaPersona) }) }); }] //Actualizar una nueva persona de la lista const actualizarPersona = [ (request,response)=>{ /*Todo esto se ejecuta solo si los datos fueron validados. Es decir, validarDatos dentro de /validator/personas.js continu\u00f3 con next() */ /*recupero el id de la persona haciendo un de-structur. La idea es crear una variable llamada id, que est\u00e1 contenida con el mismo nombre id dentro de parms*/ const {id} = request.params //creo el comando para seleccionar la persona con el id de mi tabla personas y lo guardo en sql const sql = `SELECT * FROM personas WHERE id = ${id}`; //Hago la conexi\u00f3n con mi base de datos conn.query(sql, (error, results) => { //Si se genera un error con la bd lo lanzamos if (error) throw error; // Sino se genera error, verificamos que venga algo en la respuesta, es decir que el id exista if (results.length > 0) { /*Si el id existe, almaceno en variables todos los valores que provienen del body (desestructuro) */ const {Nombre,Apellido,Edad,Mail,Celular} = request.body; /* Si el id existe, podemos modificar los datos de la persona, entonces guardamos el comando para modificar en sqlUpdate*/ const sqlUpdate = `UPDATE personas SET Nombre = '${Nombre}', Apellido = '${Apellido}', Edad = '${Edad}', Mail = '${Mail}', Celular = '${Celular}' WHERE id = ${id}; ` //Hago la conexi\u00f3n con mi base de datos conn.query(sqlUpdate,error => { //Si se genera un error con la bd lo lanzamos if (error) throw error; /* Sino se genera error, mando en mi respuesta los de la persona modificados, aqu\u00ed ya se realiz\u00f3 la sentencia de sql */ response.json({id,Nombre,Apellido,Edad,Mail,Celular}); }); } else { //Sino existe el id imprimimos el mensaje: response.status(410).json({error: \"Este id no existe\"}); } }); }] const eliminarPersona = [(request,response)=>{ /*recupero el id de la persona haciendo un de-structur. La idea es crear una variable llamada id, que est\u00e1 contenida con el mismo nombre id dentro de parms*/ const {id} = request.params //creo el comando para seleccionar la persona con el id de mi tabla personas y lo guardo en sql const sql = `SELECT * FROM personas WHERE id = ${id}`; //Hago la conexi\u00f3n con mi base de datos conn.query(sql, (error, results) => { //Si se genera un error con la bd lo lanzamos if (error) throw error; // Sino se genera error, verificamos que venga algo en la respuesta, es decir que el id exista if (results.length > 0) { // Si el id existe, lo podemos eliminar., entonces guardamos el comando para eliminar en: sqlDelete const sqlDelete = `DELETE FROM personas WHERE id = ${id};` //Hago la conexi\u00f3n con mi base de datos conn.query(sqlDelete,error => { //Si se genera un error con la bd lo lanzamos if (error) throw error; /* Sino se genera error, mando en mi respuesta el id de la persona eliminada, aqu\u00ed ya se realiz\u00f3 la sentencia de sqlDelete */ response.json(id); }); } else { //Sino existe el id imprimimos el mensaje response.status(410).json({error: \"Este id no existe\"}); } }); }] //exporto las funciones hacia mi ruta /routers/personas.js module.exports = {obtenerPersonas, obtenerPersona,a\u00f1adirPersona, actualizarPersona, eliminarPersona} Y listo!! \u00a1\u00a1\u00a1Tenemos nuestro REST-API terminado y conectado a una base de datos en la nube de Azure!!! \u00a1Fenomenal! . \u00a1\u00a1\u00a1\u00a1Aqu\u00ed te voy a dejar el repositorio con el c\u00f3digo completo y listo para ser ejecutado!!!! ------>>>> LINK DEL REPOSITORIO COMPLETO LINK","title":"C\u00f3digo"},{"location":"database/#validacion-de-los-end-points-utilizando-postman","text":"Lo siguiente es realizar nuestras pruebas, para verificar que todo est\u00e9 funcionando correctamente. Para esto te voy a dejar nuevamente un archivo tipo JSON para que podamos realizar las validaciones en POSTMAN VALIDACIONES Ingresaremos a POSTMAN, pero antes, verifiquemos el estado actual de la Tabla personas dentro de nuestra base de datos que creamos con anterioridad. Para esto vamos a ir al portal de Azure, abriremos la terminal y nos conectaremos a nuestro servidor. Una vez dentro de nuestro servidor, utilizaremos el comando USE basededatosdemoweb Posteriormente utilizaremos SELECT * FROM personas Y obtendremos esta respuesta, este es el estado actual de nuestra tabla personas, que ser\u00eda m\u00e1s o menos as\u00ed. Ahora s\u00ed, iremos a postman y con el m\u00e9todo GET tendr\u00eda que devolvernos los mismos datos que nuestra base de datos 1.- Prueba del m\u00e9todo GET que nos devuelve todas las personas \u00a1\u00a1Como pueden observar, efectivamente nos devuelve los mismos datos que nuestro base de datos!! Estamos haci\u00e9ndolo de forma correcta 2.- Prueba del m\u00e9todo GET que nos devuelve una persona por su ID, si ponemos, por ejemplo, el id No 2. Seg\u00fan nuestra base de datos, tendr\u00eda que devolvernos el API todos los datos de Carlos Guzm\u00e1n. Hacemos la petici\u00f3n en POSTMAN Efectivamente, nos devolvi\u00f3 los resultados esperados. 3.- Probemos ahora con el m\u00e9todo POST. Agregamos los datos en el body seg\u00fan nuestra definic\u00f3n y en postman obtenemos la siguiente respuesta Ahora verificamos en nuestra base de datos, que se haya a\u00f1adido correctamente la persona, para esto nuevamente en la terminal de Azure escribiremos SELECT * FROM personas \u00a1\u00a1\u00a1\u00a1Y podemos observar como en el registro con id=5 a\u00f1adi\u00f3 los datos que le mandamos desde el API!!!! Hasta ahora todo funciona muy bien. Intentemos a\u00f1adir una persona, con un dato faltante en el body Como lo esper\u00e1bamos nos arroja un error, por lo tanto, nuestras validaciones est\u00e1n funcionando correctamente 4.- Probemos ahora con el m\u00e9todo PUT para cambiar los datos de una persona, intentaremos cambiar los datos del registro 5, que intencionalmente los puse repetidos para que podamos probar nuestro m\u00e9todo PUT. Ponemos los datos en el body de acuerdo con nuestra definic\u00f3n y obtenemos la siguiente respuesta Verificamos nuevamente en nuestra base de datos, con el comando sql SELECT * FROM personas Y en efecto, nos modific\u00f3 correctamente los datos 5.- Finalmente probaremos el eliminar una persona, para esto, eliminaremos a la persona con el id=5. Esta es la respuesta obtenida de postman Por \u00faltimo, verificamos nuevamente en nuestra base de datos Y efectivamente borr\u00f3 los datos de esta persona","title":"Validaci\u00f3n de los END-POINTS utilizando POSTMAN"},{"location":"database/#siguientes-pasos","text":"\u00bfQu\u00e9 sigue ahora? Vamos a subir nuestro nuevo REST-API en un App Service de Azure, para que podamos acceder a nuestro API desde cualquier lado, pero ya no lo haremos paso a paso, puesto que esto ya lo hicimos anteriormente, sino viste esa parte del tutorial o ya olvidaste los pasos, aqu\u00ed te dejo el ENLACE para que puedas implementar este REST-API en la nube de Azure. Yo ya implement\u00e9 esto en la nube de AZURE, este es el enlace obtenido. \u00a1Te dejo por aqu\u00ed el link para que puedas probarlo tu mismo! LINK ----------------------->>>>>>>>>>>>>> https://personasapi-db.azurewebsites.net Ahora, te invito a seguir con la siguiente parte del tutorial, en donde a\u00f1adiremos un API-KEY a nuestro REST-API para que podamos tener un mejor control de \u00e9sta","title":"Siguientes pasos"},{"location":"definicion/","text":"Definici\u00f3n o Modelado del REST API utilizando Swagger Para realizar el modelado de la definici\u00f3n de nuestra API vamos a utilizar Swagger , que es un lenguaje de modelado o descripci\u00f3n de REST API. Swagger sigue los lineamientos de OpenAPI Specification (OAS). La especificaci\u00f3n OpenAPI Specification (OAS) establece una interfaz para describir una API de una manera que permita a cualquier desarrollador o aplicaci\u00f3n descubrirla y comprender completamente sus par\u00e1metros y funcionalidades, entre ellos puntos finales disponibles (end-points), operaciones permitidas en cada end point, par\u00e1metros de operaci\u00f3n, m\u00e9todos de autenticaci\u00f3n y otra informaci\u00f3n. Para m\u00e1s informaci\u00f3n acerca de lineamientos de OpenAPI Specification te recomiendo visitar este enlace --> LINK Definici\u00f3n de nuestro REST API Acceder a la p\u00e1gina de Swagger https://swagger.io/ Una vez en la p\u00e1gina hacer clic en el bot\u00f3n \"Sign In\" ubicado en la parte superior derecha A continuaci\u00f3n nos aparecer\u00e1 una pantalla para hacer Log In, hay distintas formas de loguearnos, yo recomiendo hacerlo con nuestra cuenta de GitHub Llenamos los campos con el usuario de nuestra cuenta de GitHub y damos clic en \"Sign in\" Una vez logueados correctamente nos aparecer\u00e1 la siguiente pantalla, nosotros vamos a hacer clic en el bot\u00f3n \"CREATE API\" ubicado en la parte inferior de la pantalla Nos aparecer\u00e1 la siguiente ventana, la cual llenaremos de la siguiente forma. Noten que personas-api es el nombre que decidimos para ponerle a nuestro proyecto, ustedes pueden remplazarlo por el nombre de su proyecto, y el apartado Owner a, parece de acuerdo con el perfil de GitHub con el que hayan hecho Log In. Una vez llenados todos los campos, vamos a hacer clic sobre \"Create API\" Nos aparecer\u00e1 una ventana como la siguiente. Swagger nos ayuda d\u00e1ndonos un ejemplo de c\u00f3mo comenzar y c\u00f3mo modelar nuestro REST API. Si quieres saber m\u00e1s acerca de este proceso, te invito a revisar el ejemplo que nos da Swagger, para que te familiarices con la estructura, la sintaxis y los elementos con los que trabaja Swagger para el modelado de un REST API. Nosotros borraremos el ejemplo que viene de forma determinada, e iremos escribiendo nuestra definici\u00f3n paso a paso. Comenzamos introduciendo los datos generales de nuestra API, tales como descripci\u00f3n, baseURL, versi\u00f3n, tipo de contenido que producir\u00e1 nuestra API,etc: openapi: 3.0.0 servers: # Added by API Auto Mocking Plugin - description: Personas-API url: https://virtserver.swaggerhub.com/RobertoPeredo/personas-api/1.0.0 info: description: Esta es la definici\u00f3n de un REST API que sirve para los datos de un conjunto de datos de personas version: \"1.0.0\" title: Personas-API contact: email: robertopgzm@gmail.com license: name: Apache 2.0 url: 'http://www.apache.org/licenses/LICENSE-2.0.html' 10.Despu\u00e9s de esto, definimos los componentes, que son: nuestro modelo de Persona, que son pr\u00e1cticamente todos los datos que puede tener una persona en nuestro proyecto. Tambi\u00e9n definimos el formato de los mensajes de error que devolver\u00e1n nuestros servicios. Los definimos de esta forma, para que despu\u00e9s los podamos referenciar y no tengamos que estar repitiendo c\u00f3digo. components: schemas: Persona: type: object required: - Nombre - Apellido - Edad - Mail - Celular properties: Nombre: type: string example: Roberto Apellido: type: string example: Peredo Edad: type: integer example: 25 Mail: type: string example: roberto@correo.com Celular: type: integer example: 2222222222 PersonaId: type: object required: - id - Nombre - Apellido - Edad - Mail - Celular properties: id: type: integer example: 3 Nombre: type: string example: Roberto Apellido: type: string example: Peredo Edad: type: integer example: 25 Mail: type: string example: roberto@correo.com Celular: type: integer example: 2222222222 Error: type: object required: - code - message properties: code: type: integer format: int32 example: 404 message: type: string example: NotFound 11.Finalmente definimos los endpoints y m\u00e9todos http que nuestro API tendr\u00e1: paths: /personas: ##################### GET ################# get: tags: - END-POINTS summary: Obtener los datos de todas las personas description: Al hacer la consulta GET en el path \"/personas\", recibimos como respuesta un arreglo con todos las personas y sus respectivos datos responses: '200': description: Consulta correcta content: application/json: schema: type: array items: $ref: '#/components/schemas/PersonaId' default: description: Error inesperado content: application/json: schema: $ref: '#/components/schemas/Error' ##################### POST ################# post: tags: - END-POINTS summary: A\u00f1adir el registro de una persona description: Al hacer la consulta POST en el path \"/personas\",mandamos los datos necesarios para modificar a una persona en nuestra lista de peronas requestBody: description: Datos de la persona a agregar required: true content: application/json: schema: $ref: '#/components/schemas/Persona' responses: '201': description: Registro creado content: application/json: schema: $ref: '#/components/schemas/PersonaId' default: description: Error inesperado content: application/json: schema: $ref: '#/components/schemas/Error' /personas/{id}: ##################### GET ################# get: tags: - END-POINTS summary: Obtener los datos una persona de acuerdo a su Id description: Al hacer la consulta GET en el path \"/personas/{id}\", se hace la consulta de una persona de acuerdo a su id y recibimos como respuesta un arreglo con los datos de esta persona parameters: - name: id in: path description: Id de la persona la cual se va a consultar required: true schema: type: integer responses: '200': description: Consulta correcta content: application/json: schema: $ref: '#/components/schemas/PersonaId' default: description: Error inesperado content: application/json: schema: $ref: '#/components/schemas/Error' ##################### DELETE ################# delete: tags: - END-POINTS summary: Eliminar persona de acuerdo a su Id description: Al hacer la consulta DELETE en el path \"/personas/{id}\", se hace la consulta de una persona de acuerdo a su id y se elimina de la lista de personas parameters: - name: id in: path description: Id de la persona a eliminar required: true schema: type: integer responses: '204': description: Registro eliminado content: application/json: schema: type: integer example: 3 default: description: Error inesperado content: application/json: schema: $ref: '#/components/schemas/Error' ##################### PUT ################# put: tags: - END-POINTS summary: Modifica el registro de una persona de acuerdo a su Id description: Al hacer la consulta PUT en el path \"/personas/{id}\", se hace la consulta de una persona de acuerdo a su id y se modifica el registro de la misma requestBody: description: Datos de la persona a agregar required: true content: application/json: schema: $ref: '#/components/schemas/Persona' parameters: - name: id in: path description: Id de la persona a modificar. required: true schema: type: integer responses: '204': description: Registro actualizado content: application/json: schema: $ref: '#/components/schemas/PersonaId' default: description: Error inesperado content: application/json: schema: $ref: '#/components/schemas/Error' 12.La definici\u00f3n de nuestra API est\u00e1 terminada, a continuaci\u00f3n, le comparto el LINK de nuestra API en Swagger, por si se realiza alguna modificaci\u00f3n en el futuro, para que puedan interactuar con nuestra API y para que tengan acceso al c\u00f3digo completo: PERSONAS-API Tambi\u00e9n les dejo la documentaci\u00f3n que nos genera Swagger, para que observen c\u00f3mo es que va a estar funcionando nuestro REST API DOCUMENTACI\u00d3N Pueden descargar el API en formato tipo JSON y comenzar a hacer pruebas del funcionamiento en alg\u00fan servicio como POSTMAN, nosotros lo estaremos utilizando en la siguiente parte del tutorial, la cual consiste en que una vez tengamos definida nuestra API la vamos a implementar en Node.Js \u00a1Esto es todo! Ya tenemos nuestra API definida, prototipada y lista para ser utilizada y desarrollada.","title":"2. Definici\u00f3n del REST-API (Swagger)"},{"location":"definicion/#definicion-o-modelado-del-rest-api-utilizando-swagger","text":"Para realizar el modelado de la definici\u00f3n de nuestra API vamos a utilizar Swagger , que es un lenguaje de modelado o descripci\u00f3n de REST API. Swagger sigue los lineamientos de OpenAPI Specification (OAS). La especificaci\u00f3n OpenAPI Specification (OAS) establece una interfaz para describir una API de una manera que permita a cualquier desarrollador o aplicaci\u00f3n descubrirla y comprender completamente sus par\u00e1metros y funcionalidades, entre ellos puntos finales disponibles (end-points), operaciones permitidas en cada end point, par\u00e1metros de operaci\u00f3n, m\u00e9todos de autenticaci\u00f3n y otra informaci\u00f3n. Para m\u00e1s informaci\u00f3n acerca de lineamientos de OpenAPI Specification te recomiendo visitar este enlace --> LINK","title":"Definici\u00f3n o Modelado del REST API utilizando Swagger"},{"location":"definicion/#definicion-de-nuestro-rest-api","text":"Acceder a la p\u00e1gina de Swagger https://swagger.io/ Una vez en la p\u00e1gina hacer clic en el bot\u00f3n \"Sign In\" ubicado en la parte superior derecha A continuaci\u00f3n nos aparecer\u00e1 una pantalla para hacer Log In, hay distintas formas de loguearnos, yo recomiendo hacerlo con nuestra cuenta de GitHub Llenamos los campos con el usuario de nuestra cuenta de GitHub y damos clic en \"Sign in\" Una vez logueados correctamente nos aparecer\u00e1 la siguiente pantalla, nosotros vamos a hacer clic en el bot\u00f3n \"CREATE API\" ubicado en la parte inferior de la pantalla Nos aparecer\u00e1 la siguiente ventana, la cual llenaremos de la siguiente forma. Noten que personas-api es el nombre que decidimos para ponerle a nuestro proyecto, ustedes pueden remplazarlo por el nombre de su proyecto, y el apartado Owner a, parece de acuerdo con el perfil de GitHub con el que hayan hecho Log In. Una vez llenados todos los campos, vamos a hacer clic sobre \"Create API\" Nos aparecer\u00e1 una ventana como la siguiente. Swagger nos ayuda d\u00e1ndonos un ejemplo de c\u00f3mo comenzar y c\u00f3mo modelar nuestro REST API. Si quieres saber m\u00e1s acerca de este proceso, te invito a revisar el ejemplo que nos da Swagger, para que te familiarices con la estructura, la sintaxis y los elementos con los que trabaja Swagger para el modelado de un REST API. Nosotros borraremos el ejemplo que viene de forma determinada, e iremos escribiendo nuestra definici\u00f3n paso a paso. Comenzamos introduciendo los datos generales de nuestra API, tales como descripci\u00f3n, baseURL, versi\u00f3n, tipo de contenido que producir\u00e1 nuestra API,etc: openapi: 3.0.0 servers: # Added by API Auto Mocking Plugin - description: Personas-API url: https://virtserver.swaggerhub.com/RobertoPeredo/personas-api/1.0.0 info: description: Esta es la definici\u00f3n de un REST API que sirve para los datos de un conjunto de datos de personas version: \"1.0.0\" title: Personas-API contact: email: robertopgzm@gmail.com license: name: Apache 2.0 url: 'http://www.apache.org/licenses/LICENSE-2.0.html' 10.Despu\u00e9s de esto, definimos los componentes, que son: nuestro modelo de Persona, que son pr\u00e1cticamente todos los datos que puede tener una persona en nuestro proyecto. Tambi\u00e9n definimos el formato de los mensajes de error que devolver\u00e1n nuestros servicios. Los definimos de esta forma, para que despu\u00e9s los podamos referenciar y no tengamos que estar repitiendo c\u00f3digo. components: schemas: Persona: type: object required: - Nombre - Apellido - Edad - Mail - Celular properties: Nombre: type: string example: Roberto Apellido: type: string example: Peredo Edad: type: integer example: 25 Mail: type: string example: roberto@correo.com Celular: type: integer example: 2222222222 PersonaId: type: object required: - id - Nombre - Apellido - Edad - Mail - Celular properties: id: type: integer example: 3 Nombre: type: string example: Roberto Apellido: type: string example: Peredo Edad: type: integer example: 25 Mail: type: string example: roberto@correo.com Celular: type: integer example: 2222222222 Error: type: object required: - code - message properties: code: type: integer format: int32 example: 404 message: type: string example: NotFound 11.Finalmente definimos los endpoints y m\u00e9todos http que nuestro API tendr\u00e1: paths: /personas: ##################### GET ################# get: tags: - END-POINTS summary: Obtener los datos de todas las personas description: Al hacer la consulta GET en el path \"/personas\", recibimos como respuesta un arreglo con todos las personas y sus respectivos datos responses: '200': description: Consulta correcta content: application/json: schema: type: array items: $ref: '#/components/schemas/PersonaId' default: description: Error inesperado content: application/json: schema: $ref: '#/components/schemas/Error' ##################### POST ################# post: tags: - END-POINTS summary: A\u00f1adir el registro de una persona description: Al hacer la consulta POST en el path \"/personas\",mandamos los datos necesarios para modificar a una persona en nuestra lista de peronas requestBody: description: Datos de la persona a agregar required: true content: application/json: schema: $ref: '#/components/schemas/Persona' responses: '201': description: Registro creado content: application/json: schema: $ref: '#/components/schemas/PersonaId' default: description: Error inesperado content: application/json: schema: $ref: '#/components/schemas/Error' /personas/{id}: ##################### GET ################# get: tags: - END-POINTS summary: Obtener los datos una persona de acuerdo a su Id description: Al hacer la consulta GET en el path \"/personas/{id}\", se hace la consulta de una persona de acuerdo a su id y recibimos como respuesta un arreglo con los datos de esta persona parameters: - name: id in: path description: Id de la persona la cual se va a consultar required: true schema: type: integer responses: '200': description: Consulta correcta content: application/json: schema: $ref: '#/components/schemas/PersonaId' default: description: Error inesperado content: application/json: schema: $ref: '#/components/schemas/Error' ##################### DELETE ################# delete: tags: - END-POINTS summary: Eliminar persona de acuerdo a su Id description: Al hacer la consulta DELETE en el path \"/personas/{id}\", se hace la consulta de una persona de acuerdo a su id y se elimina de la lista de personas parameters: - name: id in: path description: Id de la persona a eliminar required: true schema: type: integer responses: '204': description: Registro eliminado content: application/json: schema: type: integer example: 3 default: description: Error inesperado content: application/json: schema: $ref: '#/components/schemas/Error' ##################### PUT ################# put: tags: - END-POINTS summary: Modifica el registro de una persona de acuerdo a su Id description: Al hacer la consulta PUT en el path \"/personas/{id}\", se hace la consulta de una persona de acuerdo a su id y se modifica el registro de la misma requestBody: description: Datos de la persona a agregar required: true content: application/json: schema: $ref: '#/components/schemas/Persona' parameters: - name: id in: path description: Id de la persona a modificar. required: true schema: type: integer responses: '204': description: Registro actualizado content: application/json: schema: $ref: '#/components/schemas/PersonaId' default: description: Error inesperado content: application/json: schema: $ref: '#/components/schemas/Error' 12.La definici\u00f3n de nuestra API est\u00e1 terminada, a continuaci\u00f3n, le comparto el LINK de nuestra API en Swagger, por si se realiza alguna modificaci\u00f3n en el futuro, para que puedan interactuar con nuestra API y para que tengan acceso al c\u00f3digo completo: PERSONAS-API Tambi\u00e9n les dejo la documentaci\u00f3n que nos genera Swagger, para que observen c\u00f3mo es que va a estar funcionando nuestro REST API DOCUMENTACI\u00d3N Pueden descargar el API en formato tipo JSON y comenzar a hacer pruebas del funcionamiento en alg\u00fan servicio como POSTMAN, nosotros lo estaremos utilizando en la siguiente parte del tutorial, la cual consiste en que una vez tengamos definida nuestra API la vamos a implementar en Node.Js \u00a1Esto es todo! Ya tenemos nuestra API definida, prototipada y lista para ser utilizada y desarrollada.","title":"Definici\u00f3n de nuestro REST API"},{"location":"desarrollo/","text":"Desarrollo de la definici\u00f3n del API en Node.js (Utilizando base de datos local) Una vez teniendo la definici\u00f3n de nuestra API, conocemos ahora los end-points con los que deber de contar nuestro REST API, los tipos de datos que debemos enviarle y los tipos de respuesta que esperamos. Prerrequisitos Para continuar con la siguiente parte de nuestro tutorial, necesitamos tener instalado lo siguiente, el enlace de cada programa te lleva directamente a la p\u00e1gina oficial de cada uno para que puedas descargarlos, todos de forma gratuita. Visual Studio Code NODE POSTMAN Inicio del proyecto 1.- Crear una carpeta vac\u00eda, en el directo de nuestra preferencia con el nombre de nuestro proyecto. En esta ocasi\u00f3n a la carpeta le puse por nombre PersonasAPILocal, haciendo referencia a que este proyecto se trabajar\u00e1 con una \"base de datos\" local, como bien lo dice en el t\u00edtulo del proyecto, y lo pongo entre comillas porque en realidad vamos a guardar en un array varios objetos con los datos de algunas personas, posteriormente en la parte 4 de este tutorial, lo vamos a vincular con una base de datos en la nube de Azure. 2.- Abrimos Visual Studio y arrastramos la carpeta que creamos hacia la parte izquierda de nuestro Visual Studio, quedando de la siguiente manera: 3.- Vamos a crear un proyecto de NODE , para esto, vamos a abrir una nueva terminal en la carpeta de nuestro proyecto. Como ya tenemos abierta en VScode nuestra carpeta del proyecto, entonces simplemente vamos a ir al men\u00fa ubicado en la parte de arriba de VScode y vamos a hacer clic en \"Terminal\" y posteriormente en \"New Terminal\" 4.- Una vez abierta la terminal, vamos a escribir el comando npm init Este comando es el que nos permite arrancar un nuevo proyecto de Node. Escribimos el comando y posteriormente presionamos la tecla \"ENTER\" 5.- Despu\u00e9s de presionar enter nos aparecer\u00e1 un \"Men\u00fa\" como el que se muestra a continuaci\u00f3n, lo cual nos pide algunos datos acerca de nuestro proyecto como son: Name: (Dejaremos el nombre de la carpeta) Version: Versi\u00f3n del proyecto Description: Podemos agregar una descripci\u00f3n de nuestro proyecto. Y algunos m\u00e1s, nosotros lo llenaremos de la siguiente manera. 6.- Presionamos \"ENTER\" y nos aparecer\u00e1 un JSON con los datos introducidos, verificamos los datos y presionamos nuevamente \"ENTER\" 7.- Una vez presionado \"ENTER\", en nuestra carpeta del proyecto se genera autom\u00e1ticamente un archivo llamado \"package.json\" 8.- Como vamos a desarrollar nuestra API con ayuda de express , tenemos ahora que instalar esta dependencia. Para hacer esto, nuevamente vamos a escribir en nuestra terminal el comando: npm install express --save Ponemos el comando --save , porque es una dependencia de nuestro proyecto, no es una dependencia de desarrollo sino que es una dependencia de producci\u00f3n, es decir, para que nuestro proyecto funcione, necesita de express. Si se instal\u00f3 de forma correcto, veremos un mensaje en el terminal parecido a este. Tambi\u00e9n, se cre\u00f3 un archivo llamado \"package-lock.json\" dentro de la carpeta de nuestro proyecto. 9.- Vamos a instalar ahora Nodemon , el cual es una aplicaci\u00f3n que nos ayudar\u00e1 a recargar nuestro servidor en cuanto detecte alg\u00fan cambio, esta aplicaci\u00f3n es de mucha utilidad ya que nos ahorra tiempo por estar deteniendo y ejecutando nuevamente nuestro servidor npm i -D nodemon 10.- Instalamos ahora Body-paser con el siguiente comando: npm i body-parser Usualmente el cuerpo de una petici\u00f3n (payload), contiene informaci\u00f3n desde una petici\u00f3n tipo POST o PUT. Los desarrolladores quienes implementamos servidores, requerimos frecuentemente acceso a la informaci\u00f3n del cuerpo de dicha petici\u00f3n. El m\u00f3dulo npm body-parser permite realizar esta tarea. No es necesario programarla. Solo se requiere instalar body-parser y habilitar json() as\u00ed como url-encode como middlewares para convertir datos a JSON. 11.- Instalamos ahora express-validator con el siguiente comando: npm install --save express-validator Esta dependencia, nos ayudar\u00e1 al momento de hacer las validaciones en los end-points 12.- Vamos a instalar CORS el cual nos servir\u00e1 para poder consumir nuestra API posteriormente desde nuestro Front-end en un navegador. Si no instalamos esta dependencia, si accedemos a la url de nuestro api por ejemplo https://personasapilocal1.azurewebsites.net/personas , el navegador S\u00cd me va mostrar los resultados, pero al momento de hacer un fetch() dentro de alguna funci\u00f3n que invoque por ejemplo un bot\u00f3n, nos aparecer\u00e1 el error de CORS es por eso que vamos a instalar de una vez la dependencia npm i cors --save 13.- Por \u00faltimo vamos a crear nuestro archivo de \"index.js\" dentro de la carpeta de nuestro proyecto. Para esto vamos a hacer clic derecho sobre la carpeta de nuestro proyecto y vamos a dar clic en \" New File\" y le pondremos por nombre index.js Montaje del servidor local 1.- Lo primero que haremos es montar un peque\u00f1o servidor en nuestra computadora, para poder estar ejecutando nuestro REST-API, para esto vamos a poner el siguiente c\u00f3digo en nuestro archivo de index.js const express = require('express'); // Utilizo el m\u00f3dulo de node de express const path = require('path'); // Utilizo el m\u00f3dulo de node de path const bodyParser = require('body-parser') // Utilizo el modulo de body parser const app = express(); // Genero mi aplicaci\u00f3n de express simplemente llamando al constructor express() const port = process.env.port || 8080; // constante para nuestro puerto, es un OR para el caso de desarrollo en alg\u00fan servicio o desarrollo local app.listen(port, () =>console.log(`Escuchando en el puerto ${port}`)) 2.- Dentro de nuestro archivo de package.json . Vamos a localizar la l\u00ednea donde diga \"script\". Y dentro en \"serve\" vamos a modificar la parte de: \"serve\": \"echo \\\"Error: no test specified\\\" && exit 1\" Por: \"serve\": \"nodemon index.js\" Esto nos va a servir para que nodemon reinicie el servidor cada que realicemos un cambio. 3.- Escribimos ahora en la terminal, el comando npm run serve Y ahora s\u00ed, si todo sali\u00f3 bien, tendr\u00edamos nuestro peque\u00f1o servidor local funcionando. En la consola debi\u00f3 aparecer un mensaje como este: 4.- Una vez teniendo nuestro servidor local funcionando, vamos a crear un primer END-POINT muy sencillo antes de pasar a crear los END POINTS de nuestra definici\u00f3n. Para ello vamos a agregar unas l\u00edneas a nuestro c\u00f3digo anterior, quedando de la siguiente forma: const express = require('express'); // Utilizo el m\u00f3dulo de node de express const path = require('path'); // Utilizo el m\u00f3dulo de node de path const bodyParser = require('body-parser') // Utilizo el modulo de body parser const app = express(); // Genero mi aplicaci\u00f3n de express simplemente llamando al constructor express() // *****Lineas a\u00f1adidas*** //Route app.get('/', (req, res)=>{// Petici\u00f3n de tipo GET para nuestra API res.send(\"Bienvenido a mi API\"); }) //************* const port = process.env.port || 8080; // constante para nuestro puerto, es un OR para el caso de desarrollo en alg\u00fan servicio o desarrollo local app.listen(port, () =>console.log(`Escuchando en el puerto ${port}`)) Ahora s\u00ed, guardamos lo cambios y si todo estuvo bien. Podemos ir a nuestro navegador favorito y visitar http://localhost:8080/ , que fue el puerto en donde configuramos nuestro servidor. Que como ya sabemos, nuestro navegador por defecto siempre hace peticiones GET \u00a1Felicidades! Ya tenemos nuestra primer API funcionando, aunque no sigue para nada la definici\u00f3n que ya tenemos, a continuaci\u00f3n, voy a crear de forma correcta el API que se nos solicita: Programaci\u00f3n REST API 1.- Lo primero que tenemos que hacer es crear dos carpetas dentro de la carpeta de nuestro proyecto, vamos a crear una carpeta llamada app y dentro de esta vamos a crear 4 carpetas, una de nombre controllers , otro de nombre routers , y otra de nombre validators y a su vez dentro de cada una de estas carpetas, debemos crear un archivo de nombre personas.js . La cuarta carpeta tendr\u00e1 por nombre herlpers y dentro, crearemos un archivo llamado validateHelper.js . Quedando de la siguiente manera: Todo esto lo hacemos para tener un c\u00f3digo desacoplado y por lo tanto sea m\u00e1s entendible y mantenible. 2.- Dentro de la carpeta routers agregar dentro del archivo personas.js , el siguiente c\u00f3digo . El c\u00f3digo agregado viene con sus respectivos comentarios para mejor entendimiento del mismo. /*HOJA DE RUTAS, en esta hoja vamos a tener el control de todas las rutas de nuestra app*/ const { request } = require('express'); const res = require('express/lib/response'); const { links, json } = require('express/lib/response'); // importo el modulo de express espec\u00edficamente coon el constructor que tiene express de .Router() const endPoints = require('express').Router(); //importo las funciones desde la ruta /controllers/personas.js const {obtenerPersonas, obtenerPersona,a\u00f1adirPersona,actualizarPersona,eliminarPersona }= require('../controllers/personas') const {validarDatos}= require('../validators/personas') /* ENDPOINTS */ /*Todas las funciones como por ejemplo obtenerPersonas, realizan toda su funcionalidad en la hoja ../controllers/personas') se hace de esta forma para tener mas control en nuestro c\u00f3digo */ //Obtener todos los datos de todas las personas de la lista endPoints.get('/',obtenerPersonas) //Obtener los datos una persona de acuerdo a su Id endPoints.get('/:id', obtenerPersona) /* Agregar una nueva persona al arreglo, pero antes de a\u00f1adir valido los datos, con ayuda de ValidaDatos en este caso Validar datos es un Middleware que intercepta el mensaje, sino obtuvo ning\u00fan error deja a pasar hacia a\u00f1adirPersona con el next() que tiene internamente , si obtuvo alguno arroja el error*/ endPoints.post('/', validarDatos,a\u00f1adirPersona) /*Modificar los datos de una persona,pero antes de a\u00f1adir valido los datos, con ayuda de ValidaDatos en este caso ValidarDatos es un Middleware que intercepta el mensaje, deja a pasar hacia a\u00f1adirPersona con el next() que tiene internamente */ endPoints.put('/:id',validarDatos, actualizarPersona) //Eliminar a una persona endPoints.delete('/:id', eliminarPersona ) // Exporto todos mis endPoints para que los \"reconozca\" en index.html module.exports = endPoints; 3.- Dentro de la carpeta controllers agregar el siguiente c\u00f3digo en el archivo personas.js . El c\u00f3digo agregado viene con sus respectivos comentarios para mejor entendimiento del mismo. const { response } = require('express'); const { request } = require('express'); /* personas es el objeto en donde tenemos nuestra \"base de datos local\" Todos los cambios de post,put,delete, solo funcionan mientras el servidor est\u00e1 funcionando, en caso de reiniciar el servidor regresara a los valores actuales*/ let personas = [ { \"id\": 1, \"Nombre\": \"Roberto\", \"Apellido\": \"Peredo\", \"Edad\": 25, \"Mail\": \"roberto@correo.com\", \"Celular\": 2222222222 }, { \"id\": 2, \"Nombre\": \"Maite\", \"Apellido\": \"Cruz\", \"Edad\": 25, \"Mail\": \"maite@correo.com\", \"Celular\": 5555555555 }, { \"id\": 3, \"Nombre\": \"Juan\", \"Apellido\": \"Perez\", \"Edad\": 25, \"Mail\": \"Juan@correo.com\", \"Celular\": 6666666666 } ]; //Obtener todas las personas de la lista const obtenerPersonas = [(request, response)=>{ //Validamos si el array est\u00e1 vac\u00edo if(personas.length===0){ //En caso de estar vac\u00edo, mandamos el sig mensaje response.status(415).json({error: \"No existe ninguna persona registrada\"}); } else { //Sino est\u00e1 vaci\u00f3 desplegamos la lista de todas las personas response.json(personas)} }] //Obtener una personas de la lista de acuerdo a su ID const obtenerPersona =[(request,response)=>{ /*recupero el id de la persona haciendo un de-structur. La idea es crear una variable llamada id, que est\u00e1 contenida con el mismo nombre id dentro de parms*/ const {id} = request.params //Hago la validaci\u00f3n para ver si alg\u00fan objeto de mi arreglo personas tiene el id igual al requerido(devuelve un bool) if(personas.some( persona => persona.id === parseInt(id) )){ /*Si existe ese id en mi array, entonces: Encuentro el id que corresponda al requerido y lo devuelvo en la response de mi api Como mi variable id viene en string con parseInt convertimos a entero id, porque el id dentro del array personas es int*/ response.json(personas.find( persona => persona.id === parseInt(id) )); } else{ //Sino existe imprimimos el mensaje response.status(410).json({error: \"Este id no existe\"}); } }] //A\u00f1adir una nueva persona a la lista const a\u00f1adirPersona = [(request,response)=>{ /*Todo esto se ejecuta solo si los datos fueron validados. Es decir, validarDatos dentro de /validator/personas.js continu\u00f3 con next()*/ //Crea una variable tipo objeto, llamada nuevaPersona con los datos mandados en el body const nuevaPersona = { id: request.body.id, Nombre: request.body.Nombre, Apellido: request.body.Apellido, Edad: request.body.Edad, Mail: request.body.Mail, Celular: request.body.Celular } //Verifico si el id mandado desde la url ya existe dentro de mi arreglo de personas if(personas.some( persona => persona.id === parseInt(nuevaPersona.id) )){ //Si existe, mando el mensaje response.status(411).json({error: \"Este id ya existe\"}); } else{ //Sino existe,lo agrego con push al arreglo de personas y mando en la respuesta el obj a\u00f1adido personas.push(nuevaPersona); response.json(nuevaPersona); } }] //Actualizar una nueva persona de la lista const actualizarPersona = [ /*Todo esto se ejecuta solo si los datos fueron validados. Es decir, validarDatos dentro de /validator/personas.js continu\u00f3 con next() */ (request,response)=>{ //Si no encontr\u00f3 ning\u00fan error en la validaci\u00f3n entonces: /*recupero el id de la persona haciendo un de-structur. La idea es crear una variable llamada id, que est\u00e1 contenida con el mismo nombre id dentro de parms*/ const {id} = request.params //Verifico si el id mandado existe dentro de mi arreglo alguna persona dentro de mi array de personas if(personas.some( persona => persona.id === parseInt(id) )){ /* Si la persona s\u00ed existe, entonces almaceno en una variable llamada nuevaPersona, de tipo object, todos los valores que provienen del body */ const nuevaPersona = { id: request.body.id, Nombre: request.body.Nombre, Apellido: request.body.Apellido, Edad: request.body.Edad, Mail: request.body.Mail, Celular: request.body.Celular } //Asigno a personaAModificar todo el objeto que hace match con el id personaAModificar= personas.find( persona => persona.id === parseInt(id)) // Modifico la persona con los nuevos datos personaAModificar.id =nuevaPersona.id personaAModificar.Nombre =nuevaPersona.Nombre personaAModificar.Apellido =nuevaPersona.Apellido personaAModificar.Edad =nuevaPersona.Edad personaAModificar.Mail =nuevaPersona.Mail personaAModificar.Celular =nuevaPersona.Celular //Mando en la respuesta la persona con los datos modificados response.json(personaAModificar) } else{ //Si el id no existe, mando el mensaje response.status(410).json({error: \"Este id no existe\"}); } }] const eliminarPersona = [(request,response)=>{ /*recupero el id de la persona haciendo un de-structur. La idea es crear una variable llamada id, que est\u00e1 contenida con el mismo nombre id dentro de parms*/ const {id} = request.params //Verifico si el id mandado existe dentro de mi arreglo alguna persona dentro de mi array de personas if(personas.some( persona => persona.id === parseInt(id) )){ //Si existe, entonces 'filtro' mi array personas y solo dejo las personas que tengan un id diferente al introducido personas = personas.filter(persona => persona.id !== parseInt(id)) //Mando en mi respuesta el id de la persona eliminada response.json(id); } else { //Sino el id no existe, mando el mensaje response.status(410).json({error: \"Este id no existe\"});; } }] //exporto las funciones hacia mi ruta /routers/personas.js module.exports = {obtenerPersonas, obtenerPersona,a\u00f1adirPersona, actualizarPersona, eliminarPersona} Estos archivos, trabajan en conjunto para generar los ENDPOINT y las validaciones correspondientes para cada solicitud. Noten que como ya lo hab\u00edamos comentado, la \"base de datos\" es un arreglo dentro del mismo proyecto, por lo que, al reiniciar el servidor, todos los cambios se perder\u00e1n y el arreglo regresar\u00e1 a su contenido original. Posteriormente en la parte 4 de este tutorial, lo vamos a vincular con una base de datos en la nube de Azure. 4.-Dentro de la carpeta validators agregar el siguiente c\u00f3digo en el archivo personas.js . El c\u00f3digo agregado viene con sus respectivos comentarios para mejor entendimiento del mismo. const { response } = require('express'); const { request } = require('express'); const res = require('express/lib/response'); /*Creamos una 'variable' body que son de express-validator, las cuales nos ayudar\u00e1n a realizar las validaciones */ const { body} = require('express-validator'); /* importo la funci\u00f3n validateResult desde helpers/validateHelperes un helper para seguir el proceso o mandar un error*/ const {validateResult}= require('../helpers/validateHelper') const validarDatos = [ /*Con ayuda de las variables body y validationResult creadas con 'express-validator', validamos que los elementos que viene en el body existan, se llamen de la forma correcta y sean del tipo correcto. NOTEN que es necesario que vengan todos los datos para realizar la modificaci\u00f3n*/ body('id').exists().isNumeric(), // en la definci\u00f3n de nuestro RESTAPI no pedimos el id requerido, esto es porque en nuestra base de datos el id ser\u00e1 auto incremental, pero como lo tenemos en un arreglo, nosotros debemos asignarle el id.Mas adelante cuando nos conectamos a la base de datos, este campo desaparecer\u00e1 body('Nombre').exists().isLength({ min: 3 }), body('Apellido').exists().isLength({ min: 3 }), body('Edad').exists().isNumeric(), body('Mail').exists().isEmail(), body('Celular').exists().isNumeric(), (request,response, next)=>{ /* Desacoplamos esta funci\u00f3n para tener mejor control, entonces la mandamos a llamar y le pasamos los par\u00e1metros. nos da un resultado si consigue todas las validaciones, si consigue un error nos retorna el error sino continua el flujo con next(). Asi que simplemente la mandamos a llamar desde helpers/validateHelper */ validateResult(request,response, next) } ] module.exports = {validarDatos}//exportamos la constante para hacer uso en /routers/personajes.js como un Middleware 5.- Dentro de la carpeta helpers agregar el siguiente c\u00f3digo en el archivo validateHelper.js . El c\u00f3digo agregado viene con sus respectivos comentarios para mejor entendimiento del mismo. const { validationResult } = require('express-validator'); //Construimos una funci\u00f3n con los par\u00e1metros que nos pasan desde /validators/personas.js const validateResult = (request,response, next) =>{ try{ //si no obtuvimos ninguna error continuamos con el flujo next() validationResult(request).throw() return next() }catch(error){ // si obtuvimos alg\u00fan error lo regresamos en la respuesta response.status(400).json({ errors: error.array() }); } } module.exports={validateResult} 6.- Finalmente en nuestro archivo principal index.js vamos a agregar el siguiente c\u00f3digo, en donde vinculamos todos los c\u00f3digos anteriores. const express = require('express'); // Utilizo el m\u00f3dulo de express de Node const path = require('path'); // Utilizo el m\u00f3dulo path de Node const bodyParser = require('body-parser') // Utilizo el modulo de body parser const app = express(); // Genero mi aplicaci\u00f3n de express simplemente llamando al constructor express() const endPoints = require('./app/routers/personas')/*Importo el modulo(en este caso endPoint) que exporte desde la ruta ./app/routers/personas */ const cors = require('cors')//Utilizo el m\u00f3dulo de cors app.use(cors());//le damos acceso a nuestro API desde cualquier 'origen' //Route \"Pagina principal\" al momento de conectarse al API, con un m\u00e9todo GET que el navegador hace por default app.get('/', (req, res)=>{ res.send(\"Bienvenido a mi API\"); }) //Middleware //Body Parser (Para pasar a json los endpoint tipo post), se ejecuta antes de llegar al siguiente Middleware app.use(bodyParser.urlencoded({extended: true})); app.use(bodyParser.json()); //Middleware (registra una ruta) y ejecuta lo que viene dentro de endPoints app.use('/personas', endPoints) /*Si tuvieramos otra ruta en nuestra api como por ejemplo '/objetos', debemos crear las respectivas hojas de las carpetas controllers y routers con el mismo nombre 'objetos'*/ /* constante para nuestro puerto, es un una condici\u00f3n OR para el caso de desarrollo en alg\u00fan servicio o desarrollo local (nuestro caso) */ const port = process.env.port || 8080; app.listen(port, () =>console.log(`Escuchando en el puerto ${port}`)) Y listo, finalmente tenemos nuestro REST-API construido con Node.js y Express con base a la definici\u00f3n dada en Swagger. Ahora lo siguiente ser\u00eda realizar pruebas para cada endpoint, para esto nos ayudaremos de POSTMAN. Pruebas de funcionamiento de los ENDPOINT utilizando POSTMAN Para realizar las pruebas de funcionamiento, lo primero que debemos hacer es tener corriendo nuestro proyecto, para esto como ya sabemos debemos escribir en la terminal el comando npm run serve Una vez teniendo nuestro servidor listo, vamos a realizar las pruebas en el programa de POSTMAN, para esto te voy a dejar aqu\u00ed el archivo, para que t\u00fa mismo puedas realizar las pruebas. Basta con descargar el archivo e importarlo en POSTMAN. \u00a1No olvides hacer las solicitudes con base a la definici\u00f3n de nuestra API! Te dejo AQU\u00cd la definici\u00f3n de nuestro REST-API para que t\u00fa mismo puedas realizar las pruebas. ARCHIVO PARA PRUEBAS EN POSTMAN Prueba de la p\u00e1gina principal del API Prueba del m\u00e9todo GET que nos devuelve todas las personas Prueba del m\u00e9todo GET que nos devuelve una persona por su ID ERROR sino existe una persona con ese ID Prueba del m\u00e9todo POST que agrega una persona a la lista Si queremos agregar un ID que ya existe Si hace falta agregar en el body alg\u00fan dato de la persona Prueba del m\u00e9todo PUT que modifica los datos de una persona Si queremos modificar una id que no exista Si queremos modificar, pero hace falta un dato en el body Y Por \u00faltimo si queremos eliminar a una persona de la lista Si queremos eliminar una persona, pero no existe el id Y listo, tenemos todas las validaciones realizadas y por consiguiente un REST API funcionando a la perfecci\u00f3n. El enlace de repositorio completo, que incluye todo el c\u00f3digo es el siguiente: -------->>>>>>>>>> LINK DEL REPOSITORIO Ahora, la siguiente parte del tutorial, consiste en montar este API en un App Service de Azure para poder acceder a \u00e9ste desde cualquier lugar.","title":"3. Desarrollo del REST-API con Node.js"},{"location":"desarrollo/#desarrollo-de-la-definicion-del-api-en-nodejs-utilizando-base-de-datos-local","text":"Una vez teniendo la definici\u00f3n de nuestra API, conocemos ahora los end-points con los que deber de contar nuestro REST API, los tipos de datos que debemos enviarle y los tipos de respuesta que esperamos.","title":"Desarrollo de la definici\u00f3n del API en Node.js (Utilizando base de datos local)"},{"location":"desarrollo/#prerrequisitos","text":"Para continuar con la siguiente parte de nuestro tutorial, necesitamos tener instalado lo siguiente, el enlace de cada programa te lleva directamente a la p\u00e1gina oficial de cada uno para que puedas descargarlos, todos de forma gratuita. Visual Studio Code NODE POSTMAN","title":"Prerrequisitos"},{"location":"desarrollo/#inicio-del-proyecto","text":"1.- Crear una carpeta vac\u00eda, en el directo de nuestra preferencia con el nombre de nuestro proyecto. En esta ocasi\u00f3n a la carpeta le puse por nombre PersonasAPILocal, haciendo referencia a que este proyecto se trabajar\u00e1 con una \"base de datos\" local, como bien lo dice en el t\u00edtulo del proyecto, y lo pongo entre comillas porque en realidad vamos a guardar en un array varios objetos con los datos de algunas personas, posteriormente en la parte 4 de este tutorial, lo vamos a vincular con una base de datos en la nube de Azure. 2.- Abrimos Visual Studio y arrastramos la carpeta que creamos hacia la parte izquierda de nuestro Visual Studio, quedando de la siguiente manera: 3.- Vamos a crear un proyecto de NODE , para esto, vamos a abrir una nueva terminal en la carpeta de nuestro proyecto. Como ya tenemos abierta en VScode nuestra carpeta del proyecto, entonces simplemente vamos a ir al men\u00fa ubicado en la parte de arriba de VScode y vamos a hacer clic en \"Terminal\" y posteriormente en \"New Terminal\" 4.- Una vez abierta la terminal, vamos a escribir el comando npm init Este comando es el que nos permite arrancar un nuevo proyecto de Node. Escribimos el comando y posteriormente presionamos la tecla \"ENTER\" 5.- Despu\u00e9s de presionar enter nos aparecer\u00e1 un \"Men\u00fa\" como el que se muestra a continuaci\u00f3n, lo cual nos pide algunos datos acerca de nuestro proyecto como son: Name: (Dejaremos el nombre de la carpeta) Version: Versi\u00f3n del proyecto Description: Podemos agregar una descripci\u00f3n de nuestro proyecto. Y algunos m\u00e1s, nosotros lo llenaremos de la siguiente manera. 6.- Presionamos \"ENTER\" y nos aparecer\u00e1 un JSON con los datos introducidos, verificamos los datos y presionamos nuevamente \"ENTER\" 7.- Una vez presionado \"ENTER\", en nuestra carpeta del proyecto se genera autom\u00e1ticamente un archivo llamado \"package.json\" 8.- Como vamos a desarrollar nuestra API con ayuda de express , tenemos ahora que instalar esta dependencia. Para hacer esto, nuevamente vamos a escribir en nuestra terminal el comando: npm install express --save Ponemos el comando --save , porque es una dependencia de nuestro proyecto, no es una dependencia de desarrollo sino que es una dependencia de producci\u00f3n, es decir, para que nuestro proyecto funcione, necesita de express. Si se instal\u00f3 de forma correcto, veremos un mensaje en el terminal parecido a este. Tambi\u00e9n, se cre\u00f3 un archivo llamado \"package-lock.json\" dentro de la carpeta de nuestro proyecto. 9.- Vamos a instalar ahora Nodemon , el cual es una aplicaci\u00f3n que nos ayudar\u00e1 a recargar nuestro servidor en cuanto detecte alg\u00fan cambio, esta aplicaci\u00f3n es de mucha utilidad ya que nos ahorra tiempo por estar deteniendo y ejecutando nuevamente nuestro servidor npm i -D nodemon 10.- Instalamos ahora Body-paser con el siguiente comando: npm i body-parser Usualmente el cuerpo de una petici\u00f3n (payload), contiene informaci\u00f3n desde una petici\u00f3n tipo POST o PUT. Los desarrolladores quienes implementamos servidores, requerimos frecuentemente acceso a la informaci\u00f3n del cuerpo de dicha petici\u00f3n. El m\u00f3dulo npm body-parser permite realizar esta tarea. No es necesario programarla. Solo se requiere instalar body-parser y habilitar json() as\u00ed como url-encode como middlewares para convertir datos a JSON. 11.- Instalamos ahora express-validator con el siguiente comando: npm install --save express-validator Esta dependencia, nos ayudar\u00e1 al momento de hacer las validaciones en los end-points 12.- Vamos a instalar CORS el cual nos servir\u00e1 para poder consumir nuestra API posteriormente desde nuestro Front-end en un navegador. Si no instalamos esta dependencia, si accedemos a la url de nuestro api por ejemplo https://personasapilocal1.azurewebsites.net/personas , el navegador S\u00cd me va mostrar los resultados, pero al momento de hacer un fetch() dentro de alguna funci\u00f3n que invoque por ejemplo un bot\u00f3n, nos aparecer\u00e1 el error de CORS es por eso que vamos a instalar de una vez la dependencia npm i cors --save 13.- Por \u00faltimo vamos a crear nuestro archivo de \"index.js\" dentro de la carpeta de nuestro proyecto. Para esto vamos a hacer clic derecho sobre la carpeta de nuestro proyecto y vamos a dar clic en \" New File\" y le pondremos por nombre index.js","title":"Inicio del proyecto"},{"location":"desarrollo/#montaje-del-servidor-local","text":"1.- Lo primero que haremos es montar un peque\u00f1o servidor en nuestra computadora, para poder estar ejecutando nuestro REST-API, para esto vamos a poner el siguiente c\u00f3digo en nuestro archivo de index.js const express = require('express'); // Utilizo el m\u00f3dulo de node de express const path = require('path'); // Utilizo el m\u00f3dulo de node de path const bodyParser = require('body-parser') // Utilizo el modulo de body parser const app = express(); // Genero mi aplicaci\u00f3n de express simplemente llamando al constructor express() const port = process.env.port || 8080; // constante para nuestro puerto, es un OR para el caso de desarrollo en alg\u00fan servicio o desarrollo local app.listen(port, () =>console.log(`Escuchando en el puerto ${port}`)) 2.- Dentro de nuestro archivo de package.json . Vamos a localizar la l\u00ednea donde diga \"script\". Y dentro en \"serve\" vamos a modificar la parte de: \"serve\": \"echo \\\"Error: no test specified\\\" && exit 1\" Por: \"serve\": \"nodemon index.js\" Esto nos va a servir para que nodemon reinicie el servidor cada que realicemos un cambio. 3.- Escribimos ahora en la terminal, el comando npm run serve Y ahora s\u00ed, si todo sali\u00f3 bien, tendr\u00edamos nuestro peque\u00f1o servidor local funcionando. En la consola debi\u00f3 aparecer un mensaje como este: 4.- Una vez teniendo nuestro servidor local funcionando, vamos a crear un primer END-POINT muy sencillo antes de pasar a crear los END POINTS de nuestra definici\u00f3n. Para ello vamos a agregar unas l\u00edneas a nuestro c\u00f3digo anterior, quedando de la siguiente forma: const express = require('express'); // Utilizo el m\u00f3dulo de node de express const path = require('path'); // Utilizo el m\u00f3dulo de node de path const bodyParser = require('body-parser') // Utilizo el modulo de body parser const app = express(); // Genero mi aplicaci\u00f3n de express simplemente llamando al constructor express() // *****Lineas a\u00f1adidas*** //Route app.get('/', (req, res)=>{// Petici\u00f3n de tipo GET para nuestra API res.send(\"Bienvenido a mi API\"); }) //************* const port = process.env.port || 8080; // constante para nuestro puerto, es un OR para el caso de desarrollo en alg\u00fan servicio o desarrollo local app.listen(port, () =>console.log(`Escuchando en el puerto ${port}`)) Ahora s\u00ed, guardamos lo cambios y si todo estuvo bien. Podemos ir a nuestro navegador favorito y visitar http://localhost:8080/ , que fue el puerto en donde configuramos nuestro servidor. Que como ya sabemos, nuestro navegador por defecto siempre hace peticiones GET \u00a1Felicidades! Ya tenemos nuestra primer API funcionando, aunque no sigue para nada la definici\u00f3n que ya tenemos, a continuaci\u00f3n, voy a crear de forma correcta el API que se nos solicita:","title":"Montaje del servidor local"},{"location":"desarrollo/#programacion-rest-api","text":"1.- Lo primero que tenemos que hacer es crear dos carpetas dentro de la carpeta de nuestro proyecto, vamos a crear una carpeta llamada app y dentro de esta vamos a crear 4 carpetas, una de nombre controllers , otro de nombre routers , y otra de nombre validators y a su vez dentro de cada una de estas carpetas, debemos crear un archivo de nombre personas.js . La cuarta carpeta tendr\u00e1 por nombre herlpers y dentro, crearemos un archivo llamado validateHelper.js . Quedando de la siguiente manera: Todo esto lo hacemos para tener un c\u00f3digo desacoplado y por lo tanto sea m\u00e1s entendible y mantenible. 2.- Dentro de la carpeta routers agregar dentro del archivo personas.js , el siguiente c\u00f3digo . El c\u00f3digo agregado viene con sus respectivos comentarios para mejor entendimiento del mismo. /*HOJA DE RUTAS, en esta hoja vamos a tener el control de todas las rutas de nuestra app*/ const { request } = require('express'); const res = require('express/lib/response'); const { links, json } = require('express/lib/response'); // importo el modulo de express espec\u00edficamente coon el constructor que tiene express de .Router() const endPoints = require('express').Router(); //importo las funciones desde la ruta /controllers/personas.js const {obtenerPersonas, obtenerPersona,a\u00f1adirPersona,actualizarPersona,eliminarPersona }= require('../controllers/personas') const {validarDatos}= require('../validators/personas') /* ENDPOINTS */ /*Todas las funciones como por ejemplo obtenerPersonas, realizan toda su funcionalidad en la hoja ../controllers/personas') se hace de esta forma para tener mas control en nuestro c\u00f3digo */ //Obtener todos los datos de todas las personas de la lista endPoints.get('/',obtenerPersonas) //Obtener los datos una persona de acuerdo a su Id endPoints.get('/:id', obtenerPersona) /* Agregar una nueva persona al arreglo, pero antes de a\u00f1adir valido los datos, con ayuda de ValidaDatos en este caso Validar datos es un Middleware que intercepta el mensaje, sino obtuvo ning\u00fan error deja a pasar hacia a\u00f1adirPersona con el next() que tiene internamente , si obtuvo alguno arroja el error*/ endPoints.post('/', validarDatos,a\u00f1adirPersona) /*Modificar los datos de una persona,pero antes de a\u00f1adir valido los datos, con ayuda de ValidaDatos en este caso ValidarDatos es un Middleware que intercepta el mensaje, deja a pasar hacia a\u00f1adirPersona con el next() que tiene internamente */ endPoints.put('/:id',validarDatos, actualizarPersona) //Eliminar a una persona endPoints.delete('/:id', eliminarPersona ) // Exporto todos mis endPoints para que los \"reconozca\" en index.html module.exports = endPoints; 3.- Dentro de la carpeta controllers agregar el siguiente c\u00f3digo en el archivo personas.js . El c\u00f3digo agregado viene con sus respectivos comentarios para mejor entendimiento del mismo. const { response } = require('express'); const { request } = require('express'); /* personas es el objeto en donde tenemos nuestra \"base de datos local\" Todos los cambios de post,put,delete, solo funcionan mientras el servidor est\u00e1 funcionando, en caso de reiniciar el servidor regresara a los valores actuales*/ let personas = [ { \"id\": 1, \"Nombre\": \"Roberto\", \"Apellido\": \"Peredo\", \"Edad\": 25, \"Mail\": \"roberto@correo.com\", \"Celular\": 2222222222 }, { \"id\": 2, \"Nombre\": \"Maite\", \"Apellido\": \"Cruz\", \"Edad\": 25, \"Mail\": \"maite@correo.com\", \"Celular\": 5555555555 }, { \"id\": 3, \"Nombre\": \"Juan\", \"Apellido\": \"Perez\", \"Edad\": 25, \"Mail\": \"Juan@correo.com\", \"Celular\": 6666666666 } ]; //Obtener todas las personas de la lista const obtenerPersonas = [(request, response)=>{ //Validamos si el array est\u00e1 vac\u00edo if(personas.length===0){ //En caso de estar vac\u00edo, mandamos el sig mensaje response.status(415).json({error: \"No existe ninguna persona registrada\"}); } else { //Sino est\u00e1 vaci\u00f3 desplegamos la lista de todas las personas response.json(personas)} }] //Obtener una personas de la lista de acuerdo a su ID const obtenerPersona =[(request,response)=>{ /*recupero el id de la persona haciendo un de-structur. La idea es crear una variable llamada id, que est\u00e1 contenida con el mismo nombre id dentro de parms*/ const {id} = request.params //Hago la validaci\u00f3n para ver si alg\u00fan objeto de mi arreglo personas tiene el id igual al requerido(devuelve un bool) if(personas.some( persona => persona.id === parseInt(id) )){ /*Si existe ese id en mi array, entonces: Encuentro el id que corresponda al requerido y lo devuelvo en la response de mi api Como mi variable id viene en string con parseInt convertimos a entero id, porque el id dentro del array personas es int*/ response.json(personas.find( persona => persona.id === parseInt(id) )); } else{ //Sino existe imprimimos el mensaje response.status(410).json({error: \"Este id no existe\"}); } }] //A\u00f1adir una nueva persona a la lista const a\u00f1adirPersona = [(request,response)=>{ /*Todo esto se ejecuta solo si los datos fueron validados. Es decir, validarDatos dentro de /validator/personas.js continu\u00f3 con next()*/ //Crea una variable tipo objeto, llamada nuevaPersona con los datos mandados en el body const nuevaPersona = { id: request.body.id, Nombre: request.body.Nombre, Apellido: request.body.Apellido, Edad: request.body.Edad, Mail: request.body.Mail, Celular: request.body.Celular } //Verifico si el id mandado desde la url ya existe dentro de mi arreglo de personas if(personas.some( persona => persona.id === parseInt(nuevaPersona.id) )){ //Si existe, mando el mensaje response.status(411).json({error: \"Este id ya existe\"}); } else{ //Sino existe,lo agrego con push al arreglo de personas y mando en la respuesta el obj a\u00f1adido personas.push(nuevaPersona); response.json(nuevaPersona); } }] //Actualizar una nueva persona de la lista const actualizarPersona = [ /*Todo esto se ejecuta solo si los datos fueron validados. Es decir, validarDatos dentro de /validator/personas.js continu\u00f3 con next() */ (request,response)=>{ //Si no encontr\u00f3 ning\u00fan error en la validaci\u00f3n entonces: /*recupero el id de la persona haciendo un de-structur. La idea es crear una variable llamada id, que est\u00e1 contenida con el mismo nombre id dentro de parms*/ const {id} = request.params //Verifico si el id mandado existe dentro de mi arreglo alguna persona dentro de mi array de personas if(personas.some( persona => persona.id === parseInt(id) )){ /* Si la persona s\u00ed existe, entonces almaceno en una variable llamada nuevaPersona, de tipo object, todos los valores que provienen del body */ const nuevaPersona = { id: request.body.id, Nombre: request.body.Nombre, Apellido: request.body.Apellido, Edad: request.body.Edad, Mail: request.body.Mail, Celular: request.body.Celular } //Asigno a personaAModificar todo el objeto que hace match con el id personaAModificar= personas.find( persona => persona.id === parseInt(id)) // Modifico la persona con los nuevos datos personaAModificar.id =nuevaPersona.id personaAModificar.Nombre =nuevaPersona.Nombre personaAModificar.Apellido =nuevaPersona.Apellido personaAModificar.Edad =nuevaPersona.Edad personaAModificar.Mail =nuevaPersona.Mail personaAModificar.Celular =nuevaPersona.Celular //Mando en la respuesta la persona con los datos modificados response.json(personaAModificar) } else{ //Si el id no existe, mando el mensaje response.status(410).json({error: \"Este id no existe\"}); } }] const eliminarPersona = [(request,response)=>{ /*recupero el id de la persona haciendo un de-structur. La idea es crear una variable llamada id, que est\u00e1 contenida con el mismo nombre id dentro de parms*/ const {id} = request.params //Verifico si el id mandado existe dentro de mi arreglo alguna persona dentro de mi array de personas if(personas.some( persona => persona.id === parseInt(id) )){ //Si existe, entonces 'filtro' mi array personas y solo dejo las personas que tengan un id diferente al introducido personas = personas.filter(persona => persona.id !== parseInt(id)) //Mando en mi respuesta el id de la persona eliminada response.json(id); } else { //Sino el id no existe, mando el mensaje response.status(410).json({error: \"Este id no existe\"});; } }] //exporto las funciones hacia mi ruta /routers/personas.js module.exports = {obtenerPersonas, obtenerPersona,a\u00f1adirPersona, actualizarPersona, eliminarPersona} Estos archivos, trabajan en conjunto para generar los ENDPOINT y las validaciones correspondientes para cada solicitud. Noten que como ya lo hab\u00edamos comentado, la \"base de datos\" es un arreglo dentro del mismo proyecto, por lo que, al reiniciar el servidor, todos los cambios se perder\u00e1n y el arreglo regresar\u00e1 a su contenido original. Posteriormente en la parte 4 de este tutorial, lo vamos a vincular con una base de datos en la nube de Azure. 4.-Dentro de la carpeta validators agregar el siguiente c\u00f3digo en el archivo personas.js . El c\u00f3digo agregado viene con sus respectivos comentarios para mejor entendimiento del mismo. const { response } = require('express'); const { request } = require('express'); const res = require('express/lib/response'); /*Creamos una 'variable' body que son de express-validator, las cuales nos ayudar\u00e1n a realizar las validaciones */ const { body} = require('express-validator'); /* importo la funci\u00f3n validateResult desde helpers/validateHelperes un helper para seguir el proceso o mandar un error*/ const {validateResult}= require('../helpers/validateHelper') const validarDatos = [ /*Con ayuda de las variables body y validationResult creadas con 'express-validator', validamos que los elementos que viene en el body existan, se llamen de la forma correcta y sean del tipo correcto. NOTEN que es necesario que vengan todos los datos para realizar la modificaci\u00f3n*/ body('id').exists().isNumeric(), // en la definci\u00f3n de nuestro RESTAPI no pedimos el id requerido, esto es porque en nuestra base de datos el id ser\u00e1 auto incremental, pero como lo tenemos en un arreglo, nosotros debemos asignarle el id.Mas adelante cuando nos conectamos a la base de datos, este campo desaparecer\u00e1 body('Nombre').exists().isLength({ min: 3 }), body('Apellido').exists().isLength({ min: 3 }), body('Edad').exists().isNumeric(), body('Mail').exists().isEmail(), body('Celular').exists().isNumeric(), (request,response, next)=>{ /* Desacoplamos esta funci\u00f3n para tener mejor control, entonces la mandamos a llamar y le pasamos los par\u00e1metros. nos da un resultado si consigue todas las validaciones, si consigue un error nos retorna el error sino continua el flujo con next(). Asi que simplemente la mandamos a llamar desde helpers/validateHelper */ validateResult(request,response, next) } ] module.exports = {validarDatos}//exportamos la constante para hacer uso en /routers/personajes.js como un Middleware 5.- Dentro de la carpeta helpers agregar el siguiente c\u00f3digo en el archivo validateHelper.js . El c\u00f3digo agregado viene con sus respectivos comentarios para mejor entendimiento del mismo. const { validationResult } = require('express-validator'); //Construimos una funci\u00f3n con los par\u00e1metros que nos pasan desde /validators/personas.js const validateResult = (request,response, next) =>{ try{ //si no obtuvimos ninguna error continuamos con el flujo next() validationResult(request).throw() return next() }catch(error){ // si obtuvimos alg\u00fan error lo regresamos en la respuesta response.status(400).json({ errors: error.array() }); } } module.exports={validateResult} 6.- Finalmente en nuestro archivo principal index.js vamos a agregar el siguiente c\u00f3digo, en donde vinculamos todos los c\u00f3digos anteriores. const express = require('express'); // Utilizo el m\u00f3dulo de express de Node const path = require('path'); // Utilizo el m\u00f3dulo path de Node const bodyParser = require('body-parser') // Utilizo el modulo de body parser const app = express(); // Genero mi aplicaci\u00f3n de express simplemente llamando al constructor express() const endPoints = require('./app/routers/personas')/*Importo el modulo(en este caso endPoint) que exporte desde la ruta ./app/routers/personas */ const cors = require('cors')//Utilizo el m\u00f3dulo de cors app.use(cors());//le damos acceso a nuestro API desde cualquier 'origen' //Route \"Pagina principal\" al momento de conectarse al API, con un m\u00e9todo GET que el navegador hace por default app.get('/', (req, res)=>{ res.send(\"Bienvenido a mi API\"); }) //Middleware //Body Parser (Para pasar a json los endpoint tipo post), se ejecuta antes de llegar al siguiente Middleware app.use(bodyParser.urlencoded({extended: true})); app.use(bodyParser.json()); //Middleware (registra una ruta) y ejecuta lo que viene dentro de endPoints app.use('/personas', endPoints) /*Si tuvieramos otra ruta en nuestra api como por ejemplo '/objetos', debemos crear las respectivas hojas de las carpetas controllers y routers con el mismo nombre 'objetos'*/ /* constante para nuestro puerto, es un una condici\u00f3n OR para el caso de desarrollo en alg\u00fan servicio o desarrollo local (nuestro caso) */ const port = process.env.port || 8080; app.listen(port, () =>console.log(`Escuchando en el puerto ${port}`)) Y listo, finalmente tenemos nuestro REST-API construido con Node.js y Express con base a la definici\u00f3n dada en Swagger. Ahora lo siguiente ser\u00eda realizar pruebas para cada endpoint, para esto nos ayudaremos de POSTMAN.","title":"Programaci\u00f3n REST API"},{"location":"desarrollo/#pruebas-de-funcionamiento-de-los-endpoint-utilizando-postman","text":"Para realizar las pruebas de funcionamiento, lo primero que debemos hacer es tener corriendo nuestro proyecto, para esto como ya sabemos debemos escribir en la terminal el comando npm run serve Una vez teniendo nuestro servidor listo, vamos a realizar las pruebas en el programa de POSTMAN, para esto te voy a dejar aqu\u00ed el archivo, para que t\u00fa mismo puedas realizar las pruebas. Basta con descargar el archivo e importarlo en POSTMAN. \u00a1No olvides hacer las solicitudes con base a la definici\u00f3n de nuestra API! Te dejo AQU\u00cd la definici\u00f3n de nuestro REST-API para que t\u00fa mismo puedas realizar las pruebas. ARCHIVO PARA PRUEBAS EN POSTMAN Prueba de la p\u00e1gina principal del API Prueba del m\u00e9todo GET que nos devuelve todas las personas Prueba del m\u00e9todo GET que nos devuelve una persona por su ID ERROR sino existe una persona con ese ID Prueba del m\u00e9todo POST que agrega una persona a la lista Si queremos agregar un ID que ya existe Si hace falta agregar en el body alg\u00fan dato de la persona Prueba del m\u00e9todo PUT que modifica los datos de una persona Si queremos modificar una id que no exista Si queremos modificar, pero hace falta un dato en el body Y Por \u00faltimo si queremos eliminar a una persona de la lista Si queremos eliminar una persona, pero no existe el id Y listo, tenemos todas las validaciones realizadas y por consiguiente un REST API funcionando a la perfecci\u00f3n. El enlace de repositorio completo, que incluye todo el c\u00f3digo es el siguiente: -------->>>>>>>>>> LINK DEL REPOSITORIO Ahora, la siguiente parte del tutorial, consiste en montar este API en un App Service de Azure para poder acceder a \u00e9ste desde cualquier lugar.","title":"Pruebas de funcionamiento de los ENDPOINT utilizando POSTMAN"},{"location":"implementacion/","text":"Implementaci\u00f3n de un API en un App Services de Azure Subir nuestro proyecto a un repositorio de GitHub Creando un nuevo repositorio Lo primero que tenemos que hacer es crear un repositorio nuevo en GitHub. Para esto vamos a ir a la p\u00e1gina de GitHub y damos clic en el bot\u00f3n \"+\" que aparece en la parte superior derecha, y vamos a seleccionar \" New repository\". Vamos a colocar un nombre y una descripci\u00f3n a nuestro repositorio, en esta ocasi\u00f3n, yo nombr\u00e9 mi repositorio como \"PersonasAPILocal, posteriormente vamos llenar los dem\u00e1s datos y haremos clic en \"Create repository\" Subiendo nuestro repositorio a GitHub Nos aparecer\u00e1 un c\u00f3digo como el siguiente, el cual vamos a copiar. 2. Vamos a abrir en Visual Studio la carpeta de nuestro proyecto, y vamos a pegar en la terminal el c\u00f3digo que copiamos. Para esto, ya debes tener vinculado tu VScode con tu cuenta de GitHub 3. Vamos a presionar \"enter\", vamos a agregar un comentario para el commit y autom\u00e1ticamente se comenzar\u00e1n a subir todos los archivos de nuestro proyecto a nuestro repositorio de GitHub. Presionamos en Sync Changes, y listo. Ahora s\u00ed, tenemos nuestro Repositorio listo con todos los archivos. Link del repositorio Aqu\u00ed te dejo el link del repositorio, para que simplemente lo descargues y hagas uso de el PersonasAPILocal Subiendo nuestra API en Azure Lo primero que tenemos que hacer es tener una cuenta en portal.azure.com . Yo, por ejemplo, cre\u00e9 mi cuenta con mi correo estudiantil, el cual me otorga $100 d\u00f3lares para poder ocupar en los servicios de Azure. Una vez con nuestra cuenta logueada, procedemos a dar clic en \"crear un recurso\" Posteriormente elegimos la opci\u00f3n \u201ccrear\" en Aplicaci\u00f3n Web Ahora vamos a ir llenando poco a poco los datos que se nos solicita. Detalles del proyecto En Suscripci\u00f3n , dejar\u00e9 la que viene de forma predeterminada qu\u00e9 es \"Azure for Students\", como les coment\u00e9 esta suscripci\u00f3n viene con mi cuenta creada a partir del correo de estudiante. En el apartado de Grupo de recursos voy a hacer clic en donde dice \"Crear nuevo\" Le pondr\u00e9 por nombre * \"DemoWeb\" y har\u00e9 clic en aceptar. Detalles de instancia En el apartado de Nombre , colocar\u00e9 el nombre de nuestro proyecto hasta ahora, el cual es \"PersonasAPILocal\". Los dem\u00e1s datos deben ser preferentemente llenados como se muestran en la imagen. Es importante que en el aparto Publicar seleccionemos la opci\u00f3n \"C\u00f3digo\" Plan de App Service En el apartado de Plan de Linux lo voy a dejar por defecto, pero en SKU y tama\u00f1o voy a hacer clic en \"Cambiar tama\u00f1o\" Y en el men\u00fa del lado derecho, voy a seleccionar el \"plan de tarifa gratuito\" y a dar clic en \"Aceptar\" Por \u00faltimo, simplemente voy a dar clic en \"Revisar y crear\" Nos aparecer\u00e1 esta pantalla y haremos clic en \"Crear Implementaci\u00f3n Nos aparecer\u00e1 una pantalla como esta, y debemos dejar que se termine de realizar la implementaci\u00f3n Una vez terminada la implementaci\u00f3n, nos aparecer\u00e1 la siguiente pantalla y a continuaci\u00f3n daremos clic en \"Ir al recurso\" Iremos a la barra lateral izquierda y buscaremos la opci\u00f3n de \" Centro de implementaci\u00f3n\" y haremos clic sobre \u00e9sta. Centro de implementaci\u00f3n Origen Nos aparecer\u00e1 la siguiente ventana, y seleccionaremos GitHub como Origen de nuestro proyecto Github Debemos loguearnos con nuestro perfil de GitHub y seleccionar la organizaci\u00f3n, repositorio y rama de nuestro proyecto. Y finalmente, en la parte superior, debemos hacer clic en \"Guardar\" Actions en Github. Una vez hecho clic en \"Guardar\", autom\u00e1ticamente en nuestro repositorio de GitHub comienza a ejecutarse un Action de parte de Azure, en cuanto termine de construirse y desplegarse, tendremos acceso a nuestra API Una vez terminada el Action por parte de GitHub veremos algo as\u00ed URL de nuestro REST-API Regresamos a Azure y hacemos clic en \"Introducci\u00f3n\" \u00a1\u00a1\u00a1\u00a1\u00a1\u00a1Y con este link, tendremos acceso a nuestra API corriendo en AZURE!!!!!! \u00a1\u00a1\u00a1Este es el LINK!!! --->>>> https://personasapilocal1.azurewebsites.net Se los comparto, para que ustedes mismos realicen pruebas del RESTA API funcionando. Probaremos nuestra API nuevamente con la plataforma de POSTMAN. Les dej\u00f3 aqu\u00ed el archivo para que t\u00fa mismo puedas realizar las pruebas. Basta con descargar el archivo e importarlo en POSTMAN. \u00a1No olvides hacer las solicitudes con base a la definici\u00f3n de nuestra API! Te dejo AQUI la definici\u00f3n de nuestro REST API para que t\u00fa mismo o puedas realizar las pruebas. ARCHIVO PARA PRUEBAS EN POSTMAN En esta ocasi\u00f3n solo realizaremos la prueba de un END-POINT para que observen que todo trabaja a la perfecci\u00f3n El resto de las pruebas las omito, porque es las mismas que ya realizamos en la parte anterior del tutorial, te dejo AQU\u00cd la liga de las pruebas por si quieres revisar c\u00f3mo se hacen.","title":"4. Implementaci\u00f3n de un API en un App Services de Azure"},{"location":"implementacion/#implementacion-de-un-api-en-un-app-services-de-azure","text":"","title":"Implementaci\u00f3n de un API en un App Services de Azure"},{"location":"implementacion/#subir-nuestro-proyecto-a-un-repositorio-de-github","text":"","title":"Subir nuestro proyecto a un repositorio de GitHub"},{"location":"implementacion/#creando-un-nuevo-repositorio","text":"Lo primero que tenemos que hacer es crear un repositorio nuevo en GitHub. Para esto vamos a ir a la p\u00e1gina de GitHub y damos clic en el bot\u00f3n \"+\" que aparece en la parte superior derecha, y vamos a seleccionar \" New repository\". Vamos a colocar un nombre y una descripci\u00f3n a nuestro repositorio, en esta ocasi\u00f3n, yo nombr\u00e9 mi repositorio como \"PersonasAPILocal, posteriormente vamos llenar los dem\u00e1s datos y haremos clic en \"Create repository\"","title":"Creando un nuevo repositorio"},{"location":"implementacion/#subiendo-nuestro-repositorio-a-github","text":"Nos aparecer\u00e1 un c\u00f3digo como el siguiente, el cual vamos a copiar. 2. Vamos a abrir en Visual Studio la carpeta de nuestro proyecto, y vamos a pegar en la terminal el c\u00f3digo que copiamos. Para esto, ya debes tener vinculado tu VScode con tu cuenta de GitHub 3. Vamos a presionar \"enter\", vamos a agregar un comentario para el commit y autom\u00e1ticamente se comenzar\u00e1n a subir todos los archivos de nuestro proyecto a nuestro repositorio de GitHub. Presionamos en Sync Changes, y listo. Ahora s\u00ed, tenemos nuestro Repositorio listo con todos los archivos.","title":"Subiendo nuestro repositorio a GitHub"},{"location":"implementacion/#link-del-repositorio","text":"Aqu\u00ed te dejo el link del repositorio, para que simplemente lo descargues y hagas uso de el PersonasAPILocal","title":"Link del repositorio"},{"location":"implementacion/#subiendo-nuestra-api-en-azure","text":"Lo primero que tenemos que hacer es tener una cuenta en portal.azure.com . Yo, por ejemplo, cre\u00e9 mi cuenta con mi correo estudiantil, el cual me otorga $100 d\u00f3lares para poder ocupar en los servicios de Azure. Una vez con nuestra cuenta logueada, procedemos a dar clic en \"crear un recurso\" Posteriormente elegimos la opci\u00f3n \u201ccrear\" en Aplicaci\u00f3n Web Ahora vamos a ir llenando poco a poco los datos que se nos solicita.","title":"Subiendo nuestra API en Azure"},{"location":"implementacion/#detalles-del-proyecto","text":"En Suscripci\u00f3n , dejar\u00e9 la que viene de forma predeterminada qu\u00e9 es \"Azure for Students\", como les coment\u00e9 esta suscripci\u00f3n viene con mi cuenta creada a partir del correo de estudiante. En el apartado de Grupo de recursos voy a hacer clic en donde dice \"Crear nuevo\" Le pondr\u00e9 por nombre * \"DemoWeb\" y har\u00e9 clic en aceptar.","title":"Detalles del proyecto"},{"location":"implementacion/#detalles-de-instancia","text":"En el apartado de Nombre , colocar\u00e9 el nombre de nuestro proyecto hasta ahora, el cual es \"PersonasAPILocal\". Los dem\u00e1s datos deben ser preferentemente llenados como se muestran en la imagen. Es importante que en el aparto Publicar seleccionemos la opci\u00f3n \"C\u00f3digo\"","title":"Detalles de instancia"},{"location":"implementacion/#plan-de-app-service","text":"En el apartado de Plan de Linux lo voy a dejar por defecto, pero en SKU y tama\u00f1o voy a hacer clic en \"Cambiar tama\u00f1o\" Y en el men\u00fa del lado derecho, voy a seleccionar el \"plan de tarifa gratuito\" y a dar clic en \"Aceptar\" Por \u00faltimo, simplemente voy a dar clic en \"Revisar y crear\" Nos aparecer\u00e1 esta pantalla y haremos clic en \"Crear","title":"Plan de App Service"},{"location":"implementacion/#implementacion","text":"Nos aparecer\u00e1 una pantalla como esta, y debemos dejar que se termine de realizar la implementaci\u00f3n Una vez terminada la implementaci\u00f3n, nos aparecer\u00e1 la siguiente pantalla y a continuaci\u00f3n daremos clic en \"Ir al recurso\" Iremos a la barra lateral izquierda y buscaremos la opci\u00f3n de \" Centro de implementaci\u00f3n\" y haremos clic sobre \u00e9sta.","title":"Implementaci\u00f3n"},{"location":"implementacion/#centro-de-implementacion","text":"","title":"Centro de implementaci\u00f3n"},{"location":"implementacion/#origen","text":"Nos aparecer\u00e1 la siguiente ventana, y seleccionaremos GitHub como Origen de nuestro proyecto","title":"Origen"},{"location":"implementacion/#github","text":"Debemos loguearnos con nuestro perfil de GitHub y seleccionar la organizaci\u00f3n, repositorio y rama de nuestro proyecto. Y finalmente, en la parte superior, debemos hacer clic en \"Guardar\"","title":"Github"},{"location":"implementacion/#actions-en-github","text":"Una vez hecho clic en \"Guardar\", autom\u00e1ticamente en nuestro repositorio de GitHub comienza a ejecutarse un Action de parte de Azure, en cuanto termine de construirse y desplegarse, tendremos acceso a nuestra API Una vez terminada el Action por parte de GitHub veremos algo as\u00ed","title":"Actions en Github."},{"location":"implementacion/#url-de-nuestro-rest-api","text":"Regresamos a Azure y hacemos clic en \"Introducci\u00f3n\" \u00a1\u00a1\u00a1\u00a1\u00a1\u00a1Y con este link, tendremos acceso a nuestra API corriendo en AZURE!!!!!! \u00a1\u00a1\u00a1Este es el LINK!!! --->>>> https://personasapilocal1.azurewebsites.net Se los comparto, para que ustedes mismos realicen pruebas del RESTA API funcionando. Probaremos nuestra API nuevamente con la plataforma de POSTMAN. Les dej\u00f3 aqu\u00ed el archivo para que t\u00fa mismo puedas realizar las pruebas. Basta con descargar el archivo e importarlo en POSTMAN. \u00a1No olvides hacer las solicitudes con base a la definici\u00f3n de nuestra API! Te dejo AQUI la definici\u00f3n de nuestro REST API para que t\u00fa mismo o puedas realizar las pruebas. ARCHIVO PARA PRUEBAS EN POSTMAN En esta ocasi\u00f3n solo realizaremos la prueba de un END-POINT para que observen que todo trabaja a la perfecci\u00f3n El resto de las pruebas las omito, porque es las mismas que ya realizamos en la parte anterior del tutorial, te dejo AQU\u00cd la liga de las pruebas por si quieres revisar c\u00f3mo se hacen.","title":"URL de nuestro REST-API"},{"location":"introduccion/","text":"Introducci\u00f3n \u00bfQu\u00e9 es una API? Las API son mecanismos que permiten a dos componentes de software comunicarse entre s\u00ed mediante un conjunto de definiciones y protocolos. API significa \u201cinterfaz de programaci\u00f3n de aplicaciones\u201d. En el contexto de las API, la palabra aplicaci\u00f3n se refiere a cualquier software con una funci\u00f3n distinta. La interfaz puede considerarse como un contrato de servicio entre dos aplicaciones. Este contrato define c\u00f3mo se comunican entre s\u00ed mediante solicitudes y respuestas. La documentaci\u00f3n de su API contiene informaci\u00f3n sobre c\u00f3mo los desarrolladores deben estructurar esas solicitudes y respuestas. \u00bfC\u00f3mo funcionan las API? La arquitectura de las API suele explicarse en t\u00e9rminos de cliente y servidor. La aplicaci\u00f3n que env\u00eda la solicitud se llama cliente, y la que env\u00eda la respuesta se llama servidor. Las API pueden funcionar de cuatro maneras diferentes, seg\u00fan el momento y el motivo de su creaci\u00f3n. API de SOAP Estas API utilizan el protocolo simple de acceso a objetos. El cliente y el servidor intercambian mensajes mediante XML. Se trata de una API menos flexible que era m\u00e1s popular en el pasado. API de RPC Estas API se denominan llamadas a procedimientos remotos. El cliente completa una funci\u00f3n (o procedimiento) en el servidor, y el servidor devuelve el resultado al cliente. API de WebSocket La API de WebSocket es otro desarrollo moderno de la API web que utiliza objetos JSON para pasar datos. La API de WebSocket admite la comunicaci\u00f3n bidireccional entre las aplicaciones cliente y el servidor. El servidor puede enviar mensajes de devoluci\u00f3n de llamada a los clientes conectados, por lo que es m\u00e1s eficiente que la API de REST. API de REST Estas son las API m\u00e1s populares y flexibles que se encuentran en la web actualmente. El cliente env\u00eda las solicitudes al servidor como datos. El servidor utiliza esta entrada del cliente para iniciar funciones internas y devuelve los datos de salida al cliente. Veamos las API de REST con m\u00e1s detalle a continuaci\u00f3n. \u00bfQu\u00e9 es un REST API? REST significa transferencia de estado representacional. REST define un conjunto de funciones como GET, PUT, DELETE, etc. que los clientes pueden utilizar para acceder a los datos del servidor. Los clientes y los servidores intercambian datos mediante HTTP. La principal caracter\u00edstica de la API de REST es la ausencia de estado. La ausencia de estado significa que los servidores no guardan los datos del cliente entre las solicitudes. Las solicitudes de los clientes al servidor son similares a las URL que se escriben en el navegador para visitar un sitio web. La respuesta del servidor son datos simples, sin la t\u00edpica representaci\u00f3n gr\u00e1fica de una p\u00e1gina web. \u00bfQu\u00e9 beneficios ofrecen las API de REST? Las API de REST ofrecen cuatro beneficios principales: Integraci\u00f3n Las API se utilizan para integrar nuevas aplicaciones con los sistemas de software existentes. Esto aumenta la velocidad de desarrollo, ya que no hay que escribir cada funcionalidad desde cero. Puede utilizar las API para aprovechar el c\u00f3digo existente. Innovaci\u00f3n Sectores enteros pueden cambiar con la llegada de una nueva aplicaci\u00f3n. Las empresas deben responder con rapidez y respaldar la r\u00e1pida implementaci\u00f3n de servicios innovadores. Para ello, pueden hacer cambios en la API sin tener que reescribir todo el c\u00f3digo. Ampliaci\u00f3n Las API presentan una oportunidad \u00fanica para que las empresas satisfagan las necesidades de sus clientes en diferentes plataformas. Por ejemplo, la API de mapas permite la integraci\u00f3n de informaci\u00f3n de los mapas a trav\u00e9s de sitios web, Android, iOS, etc. Cualquier empresa puede dar un acceso similar a sus bases de datos internas mediante el uso de API gratuitas o de pago. Facilidad de mantenimiento La API act\u00faa como una puerta de enlace entre dos sistemas. Cada sistema est\u00e1 obligado a hacer cambios internos para que la API no se vea afectada. De este modo, cualquier cambio futuro que haga una de las partes en el c\u00f3digo no afectar\u00e1 a la otra. Todo esto es solo un peque\u00f1o resumen acerca de los API, pero en realidad falta mucho por aprender de estos servicios. Si te gustar\u00eda saber a\u00fan m\u00e1s acerca de las API, te invito a visitar el siguiente enlace. De donde se obtuvo la informaci\u00f3n presentada anteriormente. AWS \u00bfQu\u00e9 es un API? Ahora, veamos conceptos b\u00e1sicos acerca de las tecnolog\u00edas que estaremos utilizando \u00bfQu\u00e9 es Swagger? Swagger es un conjunto de herramientas de software de c\u00f3digo abierto para dise\u00f1ar, construir, documentar, y utilizar servicios web RESTful. Fue desarrollado por SmartBear Software e incluye documentaci\u00f3n automatizada, generaci\u00f3n de c\u00f3digo, y generaci\u00f3n de casos de prueba En otras palabras, es un lenguaje de descripci\u00f3n de REST APIs. Nosotros vamos a estar utilizando Swagger para crear la definici\u00f3n de nuestra API Para m\u00e1s informaci\u00f3n te invito a pasar al sitio oficial de Swagger Sitio oficial: https://swagger.io/ \u00bfQu\u00e9 es Node.Js? Node.js es un entorno en tiempo de ejecuci\u00f3n multiplataforma, de c\u00f3digo abierto, para la capa del servidor (pero no limit\u00e1ndose a ello) basado en el lenguaje de programaci\u00f3n JavaScript, as\u00edncrono, con E/S de datos en una arquitectura orientada a eventos y basado en el motor V8 de Google. Fue creado con el enfoque de ser \u00fatil en la creaci\u00f3n de programas de red altamente escalables, como, por ejemplo, servidores web. Para m\u00e1s informaci\u00f3n te invito a pasar al sitio oficial de Node Sitio oficial: https://nodejs.org/es/ \u00bfQu\u00e9 es Express? Express es un framework de NodeJS que proporciona caracter\u00edsticas amplias para la creaci\u00f3n de aplicaciones web y m\u00f3viles. Se utiliza para crear desde una sola p\u00e1gina, multi p\u00e1ginas, hasta aplicaciones web h\u00edbridas. Es una capa construida en NodeJS que ayuda a administrar servidores y rutas. Express fue creado para hacer API y aplicaciones web con facilidad, Cuando hacemos uso de rutas en Express tenemos acceso a: request, -->> Que son las peticiones que realiza el cliente o que se realizan desde el front-end. response -->> Es un objeto que nos sirve para enviar nuestra respuesta, puedo ser por ejemplo, un status 404, un 202, o el mensaje que devolvemos en la data. next --->> Esta es una funci\u00f3n que hace referencia a que el programa continue, si se cumplen ciertas condiciones, como su nombre lo dice con la siguiente funci\u00f3n. Para m\u00e1s informaci\u00f3n te invito a pasar al sitio oficial de Express Sitio oficial: https://expressjs.com/es/ \u00bfQu\u00e9 es SQL? SQL es un acr\u00f3nimo en ingl\u00e9s para Structured Query Language. Un Lenguaje de Consulta Estructurado. Es un tipo de lenguaje de programaci\u00f3n que te permite manipular y descargar datos de una base de datos relacional. Una de sus principales caracter\u00edsticas es el manejo del \u00e1lgebra y el c\u00e1lculo relacional para efectuar consultas con el fin de recuperar, de forma sencilla, informaci\u00f3n de bases de datos, as\u00ed como realizar cambios en ellas. Es utilizado en la mayor\u00eda de las empresas que almacenan datos en una base de datos. Ha sido y sigue siendo el lenguaje de programaci\u00f3n m\u00e1s usado para bases de datos relacionales. Para m\u00e1s informaci\u00f3n te invito a pasar al sitio oficial de MySQL Sitio oficial: https://www.mysql.com/ \u00bfQu\u00e9 Azure? Microsoft Azure es un servicio de computaci\u00f3n en la nube creado por Microsoft para construir, probar, desplegar y administrar aplicaciones y servicios mediante el uso de sus centros de datos. Proporciona software como servicio (SaaS), plataforma como servicio (PaaS) e infraestructura como servicio (IaaS) y es compatible con muchos lenguajes, herramientas y marcos de programaci\u00f3n diferentes, incluidos software y sistemas espec\u00edficos de Microsoft y de terceros. Para m\u00e1s informaci\u00f3n te invito a pasar al sitio oficial de Azure Sitio oficial: https://azure.microsoft.com/es-es/ Desarrollo Para realizar este proyecto vamos a ir mostrando paso a paso cada uno de los procesos, desde la definici\u00f3n de nuestra API hasta la implementaci\u00f3n de la misma en Azure. Para esto, vamos a dividir el proyecto, en varios proyectos terminados y funcionales, pero en cada paso lo iremos escalando un poco m\u00e1s. Cada paso estar\u00e1 contenido en una carpeta dentro de este mismo proyecto. Con base en lo anterior, los pasos que seguiremos son los siguientes: Definici\u00f3n del REST-API (Swagger) En este paso, definiremos la estructura de nuestro API, por ejemplo, cu\u00e1les ser\u00e1n sus END-POINT, c\u00f3mo y qu\u00e9 tipos de datos debemos mandarle a nuestra API para la correcta conexi\u00f3n con \u00e9sta, todo esto lo estaremos realizando con ayuda del software de Swagger Desarrollo del REST-API con Node.js Una vez teniendo bien definida nuestro API, pasaremos a implementar nuestro API con base a la definici\u00f3n realizada, esto lo haremos en Node.js. Esta API va a tener una \"base de datos local\", vamos a almacenar los datos dentro de un array dentro de nuestra misma API. Pero no te preocupes conforma vayas avanzando en el proyecto, llegaremos a conectar nuestro API directamente a una base de datos montada sobre Azure. Implementaci\u00f3n de un API en un App Services de Azure Una vez teniendo nuestro API funcionando correctamente, vamos a montar nuestro API en la nube un servicio de Azure, para que podamos tener acceso a \u00e9sta desde cualquier parte del mundo, y no limitarnos simplemente a nuestro servidor local. Creaci\u00f3n de una base de datos en Azure, modificaci\u00f3n del API para trabar con DB y vinculaci\u00f3n con el API En este apartado vamos primero a crear un servidor dentro de la nube de Azure, para posteriormente crear nuestra base de datos dentro de nuestro servidor. Vamos a modificar nuestro c\u00f3digo para poder trabajar y vincular nuestro API con nuestra base de datos. Asignaci\u00f3n de API KEY a nuestro REST API Los puntos de conexi\u00f3n de las API hacen que el sistema sea vulnerable a los ataques. La supervisi\u00f3n de las API es crucial para evitar su uso indebido. Por eso, vamos a agregarle a nuestro API un poco de seguridad implementando un API KEY en \u00e9sta. Consumo del API desde el front-end Finalmente, veremos c\u00f3mo hacer un sitio desde front-end para ver c\u00f3mo podemos hacer para consumir nuestro REST-API","title":"1. Introducci\u00f3n"},{"location":"introduccion/#introduccion","text":"","title":"Introducci\u00f3n"},{"location":"introduccion/#que-es-una-api","text":"Las API son mecanismos que permiten a dos componentes de software comunicarse entre s\u00ed mediante un conjunto de definiciones y protocolos. API significa \u201cinterfaz de programaci\u00f3n de aplicaciones\u201d. En el contexto de las API, la palabra aplicaci\u00f3n se refiere a cualquier software con una funci\u00f3n distinta. La interfaz puede considerarse como un contrato de servicio entre dos aplicaciones. Este contrato define c\u00f3mo se comunican entre s\u00ed mediante solicitudes y respuestas. La documentaci\u00f3n de su API contiene informaci\u00f3n sobre c\u00f3mo los desarrolladores deben estructurar esas solicitudes y respuestas.","title":"\u00bfQu\u00e9 es una API?"},{"location":"introduccion/#como-funcionan-las-api","text":"La arquitectura de las API suele explicarse en t\u00e9rminos de cliente y servidor. La aplicaci\u00f3n que env\u00eda la solicitud se llama cliente, y la que env\u00eda la respuesta se llama servidor. Las API pueden funcionar de cuatro maneras diferentes, seg\u00fan el momento y el motivo de su creaci\u00f3n. API de SOAP Estas API utilizan el protocolo simple de acceso a objetos. El cliente y el servidor intercambian mensajes mediante XML. Se trata de una API menos flexible que era m\u00e1s popular en el pasado. API de RPC Estas API se denominan llamadas a procedimientos remotos. El cliente completa una funci\u00f3n (o procedimiento) en el servidor, y el servidor devuelve el resultado al cliente. API de WebSocket La API de WebSocket es otro desarrollo moderno de la API web que utiliza objetos JSON para pasar datos. La API de WebSocket admite la comunicaci\u00f3n bidireccional entre las aplicaciones cliente y el servidor. El servidor puede enviar mensajes de devoluci\u00f3n de llamada a los clientes conectados, por lo que es m\u00e1s eficiente que la API de REST. API de REST Estas son las API m\u00e1s populares y flexibles que se encuentran en la web actualmente. El cliente env\u00eda las solicitudes al servidor como datos. El servidor utiliza esta entrada del cliente para iniciar funciones internas y devuelve los datos de salida al cliente. Veamos las API de REST con m\u00e1s detalle a continuaci\u00f3n.","title":"\u00bfC\u00f3mo funcionan las API?"},{"location":"introduccion/#que-es-un-rest-api","text":"REST significa transferencia de estado representacional. REST define un conjunto de funciones como GET, PUT, DELETE, etc. que los clientes pueden utilizar para acceder a los datos del servidor. Los clientes y los servidores intercambian datos mediante HTTP. La principal caracter\u00edstica de la API de REST es la ausencia de estado. La ausencia de estado significa que los servidores no guardan los datos del cliente entre las solicitudes. Las solicitudes de los clientes al servidor son similares a las URL que se escriben en el navegador para visitar un sitio web. La respuesta del servidor son datos simples, sin la t\u00edpica representaci\u00f3n gr\u00e1fica de una p\u00e1gina web.","title":"\u00bfQu\u00e9 es un REST API?"},{"location":"introduccion/#que-beneficios-ofrecen-las-api-de-rest","text":"Las API de REST ofrecen cuatro beneficios principales: Integraci\u00f3n Las API se utilizan para integrar nuevas aplicaciones con los sistemas de software existentes. Esto aumenta la velocidad de desarrollo, ya que no hay que escribir cada funcionalidad desde cero. Puede utilizar las API para aprovechar el c\u00f3digo existente. Innovaci\u00f3n Sectores enteros pueden cambiar con la llegada de una nueva aplicaci\u00f3n. Las empresas deben responder con rapidez y respaldar la r\u00e1pida implementaci\u00f3n de servicios innovadores. Para ello, pueden hacer cambios en la API sin tener que reescribir todo el c\u00f3digo. Ampliaci\u00f3n Las API presentan una oportunidad \u00fanica para que las empresas satisfagan las necesidades de sus clientes en diferentes plataformas. Por ejemplo, la API de mapas permite la integraci\u00f3n de informaci\u00f3n de los mapas a trav\u00e9s de sitios web, Android, iOS, etc. Cualquier empresa puede dar un acceso similar a sus bases de datos internas mediante el uso de API gratuitas o de pago. Facilidad de mantenimiento La API act\u00faa como una puerta de enlace entre dos sistemas. Cada sistema est\u00e1 obligado a hacer cambios internos para que la API no se vea afectada. De este modo, cualquier cambio futuro que haga una de las partes en el c\u00f3digo no afectar\u00e1 a la otra. Todo esto es solo un peque\u00f1o resumen acerca de los API, pero en realidad falta mucho por aprender de estos servicios. Si te gustar\u00eda saber a\u00fan m\u00e1s acerca de las API, te invito a visitar el siguiente enlace. De donde se obtuvo la informaci\u00f3n presentada anteriormente. AWS \u00bfQu\u00e9 es un API? Ahora, veamos conceptos b\u00e1sicos acerca de las tecnolog\u00edas que estaremos utilizando","title":"\u00bfQu\u00e9 beneficios ofrecen las API de REST?"},{"location":"introduccion/#que-es-swagger","text":"Swagger es un conjunto de herramientas de software de c\u00f3digo abierto para dise\u00f1ar, construir, documentar, y utilizar servicios web RESTful. Fue desarrollado por SmartBear Software e incluye documentaci\u00f3n automatizada, generaci\u00f3n de c\u00f3digo, y generaci\u00f3n de casos de prueba En otras palabras, es un lenguaje de descripci\u00f3n de REST APIs. Nosotros vamos a estar utilizando Swagger para crear la definici\u00f3n de nuestra API Para m\u00e1s informaci\u00f3n te invito a pasar al sitio oficial de Swagger Sitio oficial: https://swagger.io/","title":"\u00bfQu\u00e9 es Swagger?  "},{"location":"introduccion/#que-es-nodejs","text":"Node.js es un entorno en tiempo de ejecuci\u00f3n multiplataforma, de c\u00f3digo abierto, para la capa del servidor (pero no limit\u00e1ndose a ello) basado en el lenguaje de programaci\u00f3n JavaScript, as\u00edncrono, con E/S de datos en una arquitectura orientada a eventos y basado en el motor V8 de Google. Fue creado con el enfoque de ser \u00fatil en la creaci\u00f3n de programas de red altamente escalables, como, por ejemplo, servidores web. Para m\u00e1s informaci\u00f3n te invito a pasar al sitio oficial de Node Sitio oficial: https://nodejs.org/es/","title":"\u00bfQu\u00e9 es Node.Js? "},{"location":"introduccion/#que-es-express","text":"Express es un framework de NodeJS que proporciona caracter\u00edsticas amplias para la creaci\u00f3n de aplicaciones web y m\u00f3viles. Se utiliza para crear desde una sola p\u00e1gina, multi p\u00e1ginas, hasta aplicaciones web h\u00edbridas. Es una capa construida en NodeJS que ayuda a administrar servidores y rutas. Express fue creado para hacer API y aplicaciones web con facilidad, Cuando hacemos uso de rutas en Express tenemos acceso a: request, -->> Que son las peticiones que realiza el cliente o que se realizan desde el front-end. response -->> Es un objeto que nos sirve para enviar nuestra respuesta, puedo ser por ejemplo, un status 404, un 202, o el mensaje que devolvemos en la data. next --->> Esta es una funci\u00f3n que hace referencia a que el programa continue, si se cumplen ciertas condiciones, como su nombre lo dice con la siguiente funci\u00f3n. Para m\u00e1s informaci\u00f3n te invito a pasar al sitio oficial de Express Sitio oficial: https://expressjs.com/es/","title":"\u00bfQu\u00e9 es Express? "},{"location":"introduccion/#que-es-sql","text":"SQL es un acr\u00f3nimo en ingl\u00e9s para Structured Query Language. Un Lenguaje de Consulta Estructurado. Es un tipo de lenguaje de programaci\u00f3n que te permite manipular y descargar datos de una base de datos relacional. Una de sus principales caracter\u00edsticas es el manejo del \u00e1lgebra y el c\u00e1lculo relacional para efectuar consultas con el fin de recuperar, de forma sencilla, informaci\u00f3n de bases de datos, as\u00ed como realizar cambios en ellas. Es utilizado en la mayor\u00eda de las empresas que almacenan datos en una base de datos. Ha sido y sigue siendo el lenguaje de programaci\u00f3n m\u00e1s usado para bases de datos relacionales. Para m\u00e1s informaci\u00f3n te invito a pasar al sitio oficial de MySQL Sitio oficial: https://www.mysql.com/","title":"\u00bfQu\u00e9 es SQL? "},{"location":"introduccion/#que-azure","text":"Microsoft Azure es un servicio de computaci\u00f3n en la nube creado por Microsoft para construir, probar, desplegar y administrar aplicaciones y servicios mediante el uso de sus centros de datos. Proporciona software como servicio (SaaS), plataforma como servicio (PaaS) e infraestructura como servicio (IaaS) y es compatible con muchos lenguajes, herramientas y marcos de programaci\u00f3n diferentes, incluidos software y sistemas espec\u00edficos de Microsoft y de terceros. Para m\u00e1s informaci\u00f3n te invito a pasar al sitio oficial de Azure Sitio oficial: https://azure.microsoft.com/es-es/","title":"\u00bfQu\u00e9 Azure? "},{"location":"introduccion/#desarrollo","text":"Para realizar este proyecto vamos a ir mostrando paso a paso cada uno de los procesos, desde la definici\u00f3n de nuestra API hasta la implementaci\u00f3n de la misma en Azure. Para esto, vamos a dividir el proyecto, en varios proyectos terminados y funcionales, pero en cada paso lo iremos escalando un poco m\u00e1s. Cada paso estar\u00e1 contenido en una carpeta dentro de este mismo proyecto. Con base en lo anterior, los pasos que seguiremos son los siguientes: Definici\u00f3n del REST-API (Swagger) En este paso, definiremos la estructura de nuestro API, por ejemplo, cu\u00e1les ser\u00e1n sus END-POINT, c\u00f3mo y qu\u00e9 tipos de datos debemos mandarle a nuestra API para la correcta conexi\u00f3n con \u00e9sta, todo esto lo estaremos realizando con ayuda del software de Swagger Desarrollo del REST-API con Node.js Una vez teniendo bien definida nuestro API, pasaremos a implementar nuestro API con base a la definici\u00f3n realizada, esto lo haremos en Node.js. Esta API va a tener una \"base de datos local\", vamos a almacenar los datos dentro de un array dentro de nuestra misma API. Pero no te preocupes conforma vayas avanzando en el proyecto, llegaremos a conectar nuestro API directamente a una base de datos montada sobre Azure. Implementaci\u00f3n de un API en un App Services de Azure Una vez teniendo nuestro API funcionando correctamente, vamos a montar nuestro API en la nube un servicio de Azure, para que podamos tener acceso a \u00e9sta desde cualquier parte del mundo, y no limitarnos simplemente a nuestro servidor local. Creaci\u00f3n de una base de datos en Azure, modificaci\u00f3n del API para trabar con DB y vinculaci\u00f3n con el API En este apartado vamos primero a crear un servidor dentro de la nube de Azure, para posteriormente crear nuestra base de datos dentro de nuestro servidor. Vamos a modificar nuestro c\u00f3digo para poder trabajar y vincular nuestro API con nuestra base de datos. Asignaci\u00f3n de API KEY a nuestro REST API Los puntos de conexi\u00f3n de las API hacen que el sistema sea vulnerable a los ataques. La supervisi\u00f3n de las API es crucial para evitar su uso indebido. Por eso, vamos a agregarle a nuestro API un poco de seguridad implementando un API KEY en \u00e9sta. Consumo del API desde el front-end Finalmente, veremos c\u00f3mo hacer un sitio desde front-end para ver c\u00f3mo podemos hacer para consumir nuestro REST-API","title":"Desarrollo"}]}